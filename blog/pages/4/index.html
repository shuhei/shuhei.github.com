<!DOCTYPE html><html><head><title>Page 4 - Shuhei Kagawa</title><meta charset="utf-8"><meta name="viewport" content="initial-scale=1"><link rel="icon" sizes="16x16 32x32 48x48" href="/favicon.ico"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Asap:400,700"><link rel="stylesheet" href="/css/style.css"></head><body><header class="header"><h1 class="header__title"><a href="/">Shuhei Kagawa</a></h1><nav><ul class="menu"><li class="menu__item"><a href="/about">About</a></li><li class="menu__item"><a href="/works">Works</a></li><li class="menu__item"><a href="/blog/archives">Archives</a></li></ul></nav></header><div class="main"><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2015/09/26/speed-up-your-rspec-tests-by-reviewing-factory-girl">Speed up your RSpec tests by reviewing Factory Girl</a></h1><div class="meta">@<span class="date">2015-09-26 09:23</span> - <span class="category">Ruby</span>, <span class="category">Rails</span></div></div><div class="content"><p><a href="https://github.com/thoughtbot/factory_girl">Factory Girl</a> is a great tool that makes test data creation easier. However, if you don&#39;t use it properly, it may imperceptibly slow down your tests.</p>
<p>In this post, I will walk through some caveats that I stumbled upon in my current project. They could be applied not only to RSpec but I will use RSpec as an example.</p>
<h2 id="measure-measure-measure-">Measure! Measure! Measure!</h2>
<blockquote>
<p>What gets measured gets managed.</p>
<p><cite>Peter Drucker</cite></p>
</blockquote>
<p>First of all, we want to know which tests take most of the times. RSpec has <code>--profile</code>/<code>-p</code> option for the very purpose.</p>
<pre><code class="hljs sh">$ rspec --help
<span class="hljs-comment"># ...</span>
    -p, --[no-]profile [COUNT]       Enable profiling of examples and list the slowest examples (default: <span class="hljs-number">10</span>).
<span class="hljs-comment"># ...</span></code></pre><p>Let&#39;s measure your tests with it.</p>
<pre><code class="hljs sh"><span class="hljs-comment"># Run all specs with profiling.</span>
bin/rspec -p

<span class="hljs-comment"># Run specific spec file with profiling.</span>
bin/rspec spec/models/article_spec.rb -p</code></pre><p>It shows the slowest examples and groups. They should be the good point to start with.</p>
<h2 id="database-writes-are-slow">Database writes are slow</h2>
<p>There are many potential causes that slow down your tests. External API calls, file access, database access and etc. Among them, I would like to focus on database writes in this post because they are ubiquitous and relatively slow.</p>
<p>You could use mocks/stubs to completely avoid touching database. However, you may have a certain amount of code that touches database. I believe it&#39;s better to find database-related bugs with a bit slow tests than finding them on production that were overlooked by lightning-fast tests.</p>
<p>One of the Rails&#39; greatest features is that we can easily write tests that involves database queries. It&#39;s too good not to use it at all.</p>
<p>Before you consider parallel execution of tests that may introduce other complexity, you still have something to do.</p>
<h2 id="sample-project">Sample project</h2>
<p>Let&#39;s say we have a blog application with the following models:</p>
<pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  has_many <span class="hljs-symbol">:articles</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  belongs_to <span class="hljs-symbol">:author</span>
  has_many <span class="hljs-symbol">:comments</span>

  validates <span class="hljs-symbol">:author</span>, <span class="hljs-symbol">presence:</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  belongs_to <span class="hljs-symbol">:article</span>

  validates <span class="hljs-symbol">:article</span>, <span class="hljs-symbol">presence:</span> <span class="hljs-keyword">true</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edited?</span></span>
    created_at &lt; updated_at
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><p>and factories:</p>
<pre><code class="hljs ruby"><span class="hljs-constant">FactoryGirl</span>.define <span class="hljs-keyword">do</span>
  factory <span class="hljs-symbol">:author</span> <span class="hljs-keyword">do</span>
    first_name <span class="hljs-string">'Shuhei'</span>
    last_name <span class="hljs-string">'Kagawa'</span>
  <span class="hljs-keyword">end</span>

  factory <span class="hljs-symbol">:article</span> <span class="hljs-keyword">do</span>
    author
    title <span class="hljs-string">'Rails on Rails'</span>
    body <span class="hljs-string">'If you created an application that manages railway rails with the Rails framework, its name would be Rails on Rails...'</span>
  <span class="hljs-keyword">end</span>

  factory <span class="hljs-symbol">:comment</span> <span class="hljs-keyword">do</span>
    article
    commenter <span class="hljs-string">'Railer'</span>
    body <span class="hljs-string">'Great post!'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><h2 id="factorygirl-build-creates-associations">FactoryGirl.build creates associations</h2>
<p>Let&#39;s review Factory Girl&#39;s <code>create</code> and <code>build</code>. <a href="http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#create-instance_method"><code>create</code></a> instantiates an model saving it into the database just like <code>ActiveRecord::Base.create</code> does. <a href="http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#build-instance_method"><code>build</code></a> only instantiates an model without saving it just like <code>ActiveRecord::Base.new</code> does.</p>
<p>The following usage of <code>FactoryGirl.build</code> seems harmful. <code>build</code> doesn&#39;t save a <code>Comment</code> into the database while <code>create</code> does, right?</p>
<pre><code class="hljs ruby">describe <span class="hljs-constant">Comment</span>
  describe <span class="hljs-string">'#edited?'</span> <span class="hljs-keyword">do</span>
    it <span class="hljs-string">'returns true if updated after creation'</span> <span class="hljs-keyword">do</span>
      now = <span class="hljs-constant">Time</span>.zone.now
      comment = <span class="hljs-constant">FactoryGirl</span>.build(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">created_at:</span> now - <span class="hljs-number">1</span>.minute, <span class="hljs-symbol">updated_at:</span> now)

      expect(comment).to be_edited
    <span class="hljs-keyword">end</span>

    it <span class="hljs-string">'returns false right after creation'</span> <span class="hljs-keyword">do</span>
      now = <span class="hljs-constant">Time</span>.zone.now
      comment = <span class="hljs-constant">FactoryGirl</span>.build(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">created_at:</span> now, <span class="hljs-symbol">updated_at:</span> now)

      expect(comment).not_to be_edited
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><p>However, <code>build</code> actually saves the model&#39;s associations, <code>article</code> and <code>author</code> created by <code>article</code> in this case, into the database <a href="http://www.rubydoc.info/gems/factory_girl/file/GETTING_STARTED.md#Associations">unless you give <code>strategy: :build</code> option in the factory</a>. So <code>build</code> actually creates all its ancestor models, which can be a huge performance penalty if called plenty of times.</p>
<p>To avoid this behavior, you can use <a href="http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#build_stubbed-instance_method"><code>FactoryGirl.build_stubbed</code></a> instead of <code>build</code>. It builds all associations and don&#39;t save them into the database.</p>
<pre><code class="hljs ruby">comment = <span class="hljs-constant">FactoryGirl</span>.build_stubbed(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">created_at:</span> now - <span class="hljs-number">1</span>.minute, <span class="hljs-symbol">updated_at:</span> now)</code></pre><p>In this case, you even don&#39;t need to use Factory Girl because the <code>edited?</code> method doesn&#39;t involve associations. The following just works fine:</p>
<pre><code class="hljs ruby">comment = <span class="hljs-constant">Comment</span>.new(<span class="hljs-symbol">created_at:</span> now - <span class="hljs-number">1</span>.minute, <span class="hljs-symbol">updated_at:</span> now)</code></pre><p>Here is another case where unnecessary <code>post</code> is created by <code>build(:comment)</code>.</p>
<pre><code class="hljs ruby">post = <span class="hljs-constant">FactoryGirl</span>.create(<span class="hljs-symbol">:post</span>)
post.comments &lt;&lt; <span class="hljs-constant">FactoryGirl</span>.build(<span class="hljs-symbol">:comment</span>)</code></pre><p>You could do:</p>
<pre><code class="hljs ruby">post = <span class="hljs-constant">FactoryGirl</span>.create(<span class="hljs-symbol">:post</span>)
post.comments &lt;&lt; <span class="hljs-constant">FactoryGirl</span>.build(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">post:</span> <span class="hljs-keyword">nil</span>)

<span class="hljs-comment"># or</span>

post = <span class="hljs-constant">FactoryGirl</span>.create(<span class="hljs-symbol">:post</span>)
<span class="hljs-constant">FactoryGirl</span>.create(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">post:</span> post)</code></pre><h2 id="review-your-association-chain">Review your association chain</h2>
<p>There is also a case where you intentionally use <code>FactoryGirl.create</code> and create unused objects. Let&#39;s think about <code>Blog</code> model that has multiple authors and multiple posts.</p>
<pre><code class="hljs ruby"><span class="hljs-constant">FactoryGirl</span>.define <span class="hljs-keyword">do</span>
  factory <span class="hljs-symbol">:blog</span> <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">end</span>

  factory <span class="hljs-symbol">:author</span> <span class="hljs-keyword">do</span>
    blog
  <span class="hljs-keyword">end</span>

  factory <span class="hljs-symbol">:post</span> <span class="hljs-keyword">do</span>
    author
    blog
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><p>With the setup above, <code>FactoryGirl.create(:post)</code> <strong>creates blog twice</strong>, once in the <code>post</code> factory and once in the <code>author</code> factory. Not only is it redundant, but also it may introduce data inconsistency because the two <code>blog</code> instances are different.</p>
<p>The <code>post</code> factory could reuse the <code>author</code>&#39;s <code>blog</code>.</p>
<pre><code class="hljs ruby">factory <span class="hljs-symbol">:post</span> <span class="hljs-keyword">do</span>
  author
  blog { author.blog }
<span class="hljs-keyword">end</span></code></pre><h2 id="summary">Summary</h2>
<p>To recap, there are things to consider before you stub everything or start considering parallel execution of tests. Imagine what Factory Girl exactly does and review your tests and factories. You will be able to speed up your tests for relatively cheaper cost.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://github.com/thoughtbot/factory_girl">Factory Girl</a></li>
<li><a href="https://robots.thoughtbot.com/speed-up-tests-by-selectively-avoiding-factory-girl">Speed Up Tests by Selectively Avoiding Factory Girl</a></li>
<li><a href="https://robots.thoughtbot.com/use-factory-girls-build-stubbed-for-a-faster-test">Use Factory Girl&#39;s build_stubbed for a Faster Test Suite</a></li>
</ul>
</div></div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2015/09/21/using-highlight-js-with-marked">Using highlight.js with marked</a></h1><div class="meta">@<span class="date">2015-09-21 18:09</span> - <span class="category">JavaScript</span></div></div><div class="content"><p>I use <a href="https://github.com/chjj/marked">marked</a> to parse markdown files of posts and pages, and <a href="https://github.com/isagalaev/highlight.js">highlight.js</a> to highlight code blocks in them for this site. Here are problems that I came across to make them work together and a workaround for them.</p>
<p>marked&#39;s README has <a href="https://github.com/chjj/marked#highlight">an example on how to configure it to work with highlight.js</a> but it doesn&#39;t add <code>hljs</code> classes on <code>&lt;code&gt;</code> tags that highlight.js uses to style code blocks. At the moment, you have to <a href="https://github.com/chjj/marked/pull/418#issuecomment-57291402">prepare your own renderer</a> to achieve it.</p>
<p>Also, you need to check whether the language given by marked is a valid one for highlight.js. <a href="https://github.com/chjj/marked/issues/311#issuecomment-31182632">highlight.js seems to have had <code>LANGUAGES</code> property a few years ago</a> but now <code>getLanguage()</code> method serves as a substitute for it.</p>
<p>Here&#39;s the outcome:</p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> marked, { Renderer } <span class="hljs-keyword">from</span> <span class="hljs-string">'marked'</span>;
<span class="hljs-keyword">import</span> highlightjs <span class="hljs-keyword">from</span> <span class="hljs-string">'highlight.js'</span>;

<span class="hljs-comment">// Create your custom renderer.</span>
<span class="hljs-keyword">const</span> renderer = <span class="hljs-keyword">new</span> Renderer();
renderer.code = (code, language) =&gt; {
  <span class="hljs-comment">// Check whether the given language is valid for highlight.js.</span>
  <span class="hljs-keyword">const</span> validLang = !!(language &amp;&amp; highlightjs.getLanguage(language));
  <span class="hljs-comment">// Highlight only if the language is valid.</span>
  <span class="hljs-keyword">const</span> highlighted = validLang ? highlightjs.highlight(language, code).value : code;
  <span class="hljs-comment">// Render the highlighted code with `hljs` class.</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;pre&gt;&lt;code class="hljs <span class="hljs-subst">${language}</span>"&gt;<span class="hljs-subst">${highlighted}</span>&lt;/code&gt;&lt;/pre&gt;`</span>;
};

<span class="hljs-comment">// Set the renderer to marked.</span>
marked.setOptions({ renderer });</code></pre></div></div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2015/09/13/lets-create-a-babel-plugin">Let's create a Babel plugin</a></h1><div class="meta">@<span class="date">2015-09-13 14:22</span> - <span class="category">JavaScript</span>, <span class="category">Babel</span></div></div><div class="content"><p><a href="https://babeljs.io/">Babel</a> is the great tool that transpiles ES2015, ES7, JSX and such into ES5 and make them available on the browsers. If you are a person like me, you might use it on a daily basis.</p>
<p>In addition to to <a href="https://babeljs.io/docs/advanced/transformers/">the built-in transformers</a>, you can add your own transpilation rules by employing third-party plugins. For example, I have been developing <a href="https://github.com/shuhei/babel-plugin-angular2-annotations">a plugin that enables you to write Angular 2 apps with Babel</a> lately. It is easier to develop than you may think. Let me introduce how to create a plugin for Babel 5.x.</p>
<h2 id="how-babel-works">How Babel works</h2>
<p>Simply put, Babel works like the following:</p>
<ol>
<li>Babylon, the parser of Babel, parses source code into AST.</li>
<li>Transformers transforms AST into another AST in sequence.</li>
<li>Generators generates JavaScript code from the final AST.</li>
</ol>
<p>In the step 1, AST is for <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>, which represents the structure of source code as a tree. Babel&#39;s AST is based on a specfication called ESTree and has some extensions for non-standard nodes like ES7+, JSX and flowtype. You can check the ESTree spec at the following links:</p>
<ul>
<li><a href="https://github.com/estree/estree/blob/master/spec.md">Core</a></li>
<li><a href="https://github.com/estree/estree/blob/master/es6.md">ES6</a></li>
</ul>
<p>In the step 2, transformers consists of <a href="https://babeljs.io/docs/advanced/transformers/">the built-in transformers</a>, like <a href="es6.classes">es6.classes</a>, and third-party plugin transformers. As of Babel 6.0, the built-in transpilers will also be extracted as external plugin modules. So there will be no border between the build-in and third-party plugins.</p>
<p>So, what you have to do is write a transformer that transforms AST into another AST. You don&#39;t need to parse JS or generate JS from AST by yourself. It will be greatly effective compared to introducing another tool that parses JS by its own. Also, Babel&#39;s powerful API will make it easier than using the raw esprima tools.</p>
<h2 id="what-you-can-not-do">What you can (not) do</h2>
<p>You can do almost anything as long as it&#39;s in the syntax that Babylon supports, ES2015, ES7+, JSX, flowtype and etc. You can&#39;t introduce new syntax because Babel currently doesn&#39;t support parser extension by plugins. (You can actually accomplish it by monkey-patching Babylon though.)</p>
<h2 id="create-a-project">Create a project</h2>
<p>Create a directory in the format of <code>babel-plugin-*</code>. The <code>*</code> part turns to be your plugin name. In the directory, you can create a Babel plugin project with <code>babel-plugin init</code>, which is installed by <code>npm install -g babel</code>.</p>
<pre><code class="hljs sh"><span class="hljs-comment"># Prepare a project directory.</span>
mkdir babel-plugin-foo-bar
<span class="hljs-built_in">cd</span> babel-plugin-foo-bar
<span class="hljs-comment"># Generate necessary files.</span>
npm install -g babel
babel-plugin init
<span class="hljs-comment"># Install dependencies.</span>
npm install</code></pre><p>The following structure should have been generated:</p>
<pre><code class="hljs undefined">.
├── .gitignore
├── .npmigonore
├── LICENSE
├── README.md
├── node_modules
├── package.json
└── src
    └── index.js</code></pre><p>You will find some npm-run-scripts in the <code>package.json</code>:</p>
<ul>
<li><code>npm run build</code> transpiles files under <code>src</code> directory with Babel and output the result into <code>lib</code> directory.</li>
<li><code>npm run push</code> releases a newer version of the plugin. It takes care of git commit, tag and npm package.</li>
<li><code>npm test</code> runs <code>babel-plugin test</code> but fails because the command doesn&#39;t exist. <a href="https://github.com/babel/babel/issues/1950">It seems like it will work in the future.</a> So, prepare your favorite test runner like <code>mocha</code> for now.</li>
</ul>
<p>With this setup, you can write your plugin itself with Babel&#39;s features. <code>src</code> should be ignored in npm and <code>lib</code> in git.</p>
<h2 id="transformer">Transformer</h2>
<p><code>src/index.js</code>, the meat of the plugin, looks like this:</p>
<pre><code class="hljs js"><span class="hljs-comment">/* eslint no-unused-vars:0 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Plugin, types: t }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Plugin(<span class="hljs-string">"foo"</span>, {
    visitor: {
      <span class="hljs-comment">// your visitor methods go here</span>
    }
  });
}</code></pre><p>It exports a factory function that creates a <code>Plugin</code> instance. The <code>Plugin</code> constructor gets the plugin&#39;s name and a configuration object.</p>
<p>The <code>visitor</code> property holds methods named as AST node types. A Babel transformer traverses AST from the top to the bottom. Each method is called when the trasnformer visits the matched nodes. For instance, you can manipulate class declarations and function declarations as the following:</p>
<pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Plugin, types: t }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Plugin(<span class="hljs-string">"foo"</span>, {
    visitor: {
      ClassDeclaration(node, parent) {
        <span class="hljs-comment">// Do something on a class declaration node.</span>
      },
      FunctionDeclaration(node, parent) {
        <span class="hljs-comment">// Do something on a function declaration node.</span>
      }
    }
  });
};</code></pre><p>You can also use <code>alias</code> instead of plain node types to match multiple node types. For example, <code>Function</code> matches against <code>FunctionDeclaration</code> and <code>FunctionExpression</code>.</p>
<p><code>types</code> is another important thing. It contains a bunch of utility functions for AST manipulation.</p>
<ul>
<li>AST node generation functions such as <code>identifier()</code>, <code>memberExpression()</code> and <code>assignmentExpression</code>. Their names are lowerCamelCased versions of the corresponding node types. You can check their arguments at <a href="https://github.com/babel/babel/tree/master/packages/babel/src/types/definitions">definitions</a>&#39; <code>builder</code> properties.</li>
<li>AST node check functions such as <code>isIdentifier()</code> and <code>isDecorator()</code>. You can shallowly check node properties with the second argument.</li>
</ul>
<p>The functions are <a href="https://github.com/babel/babel/blob/v5.8.24/packages/babel/src/types/index.js">generated</a> from <a href="https://github.com/babel/babel/tree/master/packages/babel/src/types/definitions">definitions</a>。The definitions will serve as a reference.</p>
<p>The best examples of AST transformation using <code>types</code> functions are undoubtedly <a href="https://github.com/babel/babel/tree/v5.8.24/packages/babel/src/transformation/transformers">the source code of the built-in transformers</a>. Pick the closest one to what you want from <a href="https://babeljs.io/docs/advanced/transformers/">the list</a> and check out the source code. <a href="https://babeljs.io/docs/advanced/plugins/">The official documentation</a> will also help.</p>
<h2 id="case-study-assign-class-constructor-s-arguments-as-instance-properties">Case study: Assign class constructor&#39;s arguments as instance properties</h2>
<p>As a case study, I built a plugin called <a href="https://github.com/shuhei/babel-plugin-auto-assign">babel-plugin-auto-assign</a> that &quot;assigns class constructor&#39;s arguments as instance properties&quot;, which resembles TypeScript&#39;s parameter properties in its action. It is intended to be used with class-based dependency injection like Angular&#39;s.</p>
<p>To avoid unawarely messing up constructors, let&#39;s apply the transformation only to classes with a decrator called <code>@autoAssign</code>. <code>@autoAssign</code> is a so-called <a href="https://github.com/jonathandturner/brainstorming/blob/master/README.md#c6-ambient-decorators">ambient decorator</a> because it should not appear in the output.</p>
<p>Before:</p>
<pre><code class="hljs js">@autoAssign
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>{
  constructor(foo, bar, baz) {
  }
}</code></pre><p>After:</p>
<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>{
  constructor(foo, bar, baz) {
    <span class="hljs-keyword">this</span>.foo = foo;
    <span class="hljs-keyword">this</span>.bar = bar;
    <span class="hljs-keyword">this</span>.baz = baz;
  }
}</code></pre><p>Note that we can leave the ES6 class as is because it&#39;s going to be transformed to ES5 by the subsequent built-in transformers. Babel plugin transformers are applied <strong>before</strong> the built-in transformers by default. If you want to apply a plugin after the built-in transformers, suffix the plugin name with <code>:after</code> like <code>babel --plugins foo:after index.js</code>.</p>
<h2 id="ast-before-after-transformation">AST before/after transformation</h2>
<p>To transform AST, we need to know how the starting post and the goal look like. You can visualize source code in AST parsed by Babylon with <a href="http://felix-kling.de/esprima_ast_explorer">Felix Kling&#39;s JS AST Explorer</a>.</p>
<ul>
<li><a href="http://felix-kling.de/esprima_ast_explorer/#/OuFSNzgCl2">Before transformation</a></li>
<li><a href="http://felix-kling.de/esprima_ast_explorer/#/tZsOQTyns6">After transformation</a></li>
</ul>
<p>It also works to examine nodes with <code>console.log()</code>.</p>
<h2 id="code">Code</h2>
<p>Once you get the ASTs, half of the work is done. Let&#39;s write some code to insert AST nodes using <code>types</code> functions.</p>
<p><a href="https://github.com/shuhei/babel-plugin-auto-assign">The complete project</a> includes unit testing with fixtures.</p>
<p><code>src/index.js</code></p>
<pre><code class="hljs js"><span class="hljs-keyword">import</span> AutoAssign <span class="hljs-keyword">from</span> <span class="hljs-string">'./auto-assign'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">{ Plugin, types: t }</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Plugin(<span class="hljs-string">'autoAssign'</span>, {
    visitor: {
      ClassDeclaration: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node, parent</span>) </span>{
        <span class="hljs-keyword">new</span> AutoAssign(t).run(node);
      }
    }
  });
}</code></pre><p><code>src/auto-assign.js</code></p>
<pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoAssign</span> </span>{
  constructor(types) {
    <span class="hljs-keyword">this</span>.types = types;
  }

  run(klass) {
    <span class="hljs-comment">// Process only if `@autoAssign` decorator exists.</span>
    <span class="hljs-keyword">const</span> decorators = <span class="hljs-keyword">this</span>.findautoAssignDecorators(klass);
    <span class="hljs-keyword">if</span> (decorators.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// Get constructor and its paremeters.</span>
      <span class="hljs-keyword">const</span> ctor = <span class="hljs-keyword">this</span>.findConstructor(klass);
      <span class="hljs-keyword">const</span> args = <span class="hljs-keyword">this</span>.getArguments(ctor);
      <span class="hljs-comment">// Prepend assignment statements to the constructor.</span>
      <span class="hljs-keyword">this</span>.prependAssignments(ctor, args);
      <span class="hljs-comment">// Delete `@autoAssign`.</span>
      <span class="hljs-keyword">this</span>.deleteDecorators(klass, decorators);
    }
  }

  findautoAssignDecorators(klass) {
    <span class="hljs-keyword">return</span> (klass.decorators || []).filter((decorator) =&gt; {
      <span class="hljs-keyword">return</span> decorator.expression.name === <span class="hljs-string">'autoAssign'</span>;
    });
  }

  deleteDecorators(klass, decorators) {
    decorators.forEach((decorator) =&gt; {
      <span class="hljs-keyword">const</span> index = klass.decorators.indexOf(decorator);
      <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        klass.decorators.splice(index, <span class="hljs-number">1</span>);
      }
    });
  }

  findConstructor(klass) {
    <span class="hljs-keyword">return</span> klass.body.body.filter((body) =&gt; {
      <span class="hljs-keyword">return</span> body.kind === <span class="hljs-string">'constructor'</span>;
    })[<span class="hljs-number">0</span>];
  }

  getArguments(ctor) {
    <span class="hljs-keyword">return</span> ctor.value.params;
  }

  prependAssignments(ctor, args) {
    <span class="hljs-keyword">const</span> body = ctor.value.body.body;
    args.slice().reverse().forEach((arg) =&gt; {
      <span class="hljs-keyword">const</span> assignment = <span class="hljs-keyword">this</span>.buildAssignment(arg);
      body.unshift(assignment);
    });
  }

  buildAssignment(arg) {
    <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>.types.identifier(<span class="hljs-string">'this'</span>);
    <span class="hljs-keyword">const</span> prop = <span class="hljs-keyword">this</span>.types.memberExpression(self, arg);
    <span class="hljs-keyword">const</span> assignment = <span class="hljs-keyword">this</span>.types.assignmentExpression(<span class="hljs-string">'='</span>, prop, arg);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.types.expressionStatement(assignment);
  }
}</code></pre><h2 id="run-">Run!</h2>
<p>Use <code>--optional es7.decorators</code> option in order to support decorators. You can specify plugins by file path in addition to plugin name, which is convenient for development.</p>
<pre><code class="hljs undefined">npm run build
echo '@autoAssign class Hello { constructor(foo, bar, baz) {} }' | babel --optional es7.decorators --plugins ./lib/index.js</code></pre><p>Here comes the result!</p>
<pre><code class="hljs js"><span class="hljs-pi">"use strict"</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) </span>{ <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> Constructor)) { <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">"Cannot call a class as a function"</span>); } }

<span class="hljs-keyword">var</span> Hello = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Hello</span>(<span class="hljs-params">foo, bar, baz</span>) </span>{
    _classCallCheck(<span class="hljs-keyword">this</span>, _Hello);

    <span class="hljs-keyword">this</span>.foo = foo;
    <span class="hljs-keyword">this</span>.bar = bar;
    <span class="hljs-keyword">this</span>.baz = baz;
  }

  <span class="hljs-keyword">var</span> _Hello = Hello;
  <span class="hljs-keyword">return</span> Hello;
})();</code></pre><h2 id="publish">Publish</h2>
<p>After you write README and commit it, you can publish your plugin to the world by <code>npm run push</code>.</p>
<p>Let&#39;s create awesome babel plugins!</p>
<h2 id="references">References</h2>
<h3 id="documentation">Documentation</h3>
<ul>
<li><a href="https://babeljs.io/docs/advanced/plugins/">Plugins - Babel</a></li>
<li><a href="https://github.com/estree/estree">ESTree</a></li>
<li><a href="https://github.com/babel/babel/tree/v5.8.24/packages/babel/src/transformation/transformers">Built-in transformers</a></li>
</ul>
<h3 id="projects">Projects</h3>
<ul>
<li><a href="https://github.com/estree/estree">shuhei/babel-plugin-auto-assign</a> The case study project in this article.</li>
<li><a href="https://github.com/shuhei/babel-plugin-angular2-annotations">shuhei/babel-plugin-angular2-annotations</a> A plugin for building Angular 2 app with Babel. It supports TypeScript-like method parameter decorators by monkey-patching Babylon.</li>
</ul>
</div></div><ul class="pagination"><li class="pagination__prev-page"><a href="/blog/pages/3">Newer Posts</a></li><li class="pagination__archives"><a href="/blog/archives">Archives</a></li><li class="pagination__next-page"><a href="/blog/pages/5">Older Posts</a></li></ul></div><footer class="footer">&copy; Shuhei Kagawa<script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-309586-8', 'shuheikagawa.com');
ga('send', 'pageview');</script></footer></body></html>