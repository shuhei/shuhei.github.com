<!doctype html>
    <html >
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="initial-scale=1">
        <title data-react-helmet="true">Page 4 - Shuhei Kagawa</title>
        <link rel="icons" sizes="16x16 32x32 48x48" href="/favicon.ico">
        <link rel="alternate" type="application/rss+xml" title="RSS Feed for shuheikagawa.com" href="/blog/feed/rss.xml">
        <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Asap:4000,700">
        <link rel="stylesheet" href="/css/style.css">
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-309586-8', 'shuheikagawa.com');
          ga('send', 'pageview');
        </script>
      </head>
      <body>
        <div id="container"><div data-reactroot="" data-reactid="1" data-react-checksum="-413352650"><header class="header" data-reactid="2"><h1 class="header__title" data-reactid="3"><a href="/" data-reactid="4">Shuhei Kagawa</a></h1><nav data-reactid="5"><ul class="menu" data-reactid="6"><li class="menu__item" data-reactid="7"><a href="/about/" data-reactid="8">About</a></li><li class="menu__item" data-reactid="9"><a href="/works/" data-reactid="10">Works</a></li><li class="menu__item" data-reactid="11"><a href="/blog/archives/" data-reactid="12">Archives</a></li></ul></nav></header><div class="main" data-reactid="13"><div data-reactid="14"><!-- react-empty: 15 --><div class="post" data-reactid="16"><div class="post-header" data-reactid="17"><h1 class="title" data-reactid="18"><a href="/blog/2015/10/25/node-executable-module/" data-reactid="19">Node.js executable module</a></h1><div class="meta" data-reactid="20"><!-- react-text: 21 -->@<!-- /react-text --><span class="date" data-reactid="22">2015-10-25 22:42</span><!-- react-text: 23 --> - <!-- /react-text --><span class="category" data-reactid="24">JavaScript</span></div></div><div class="content" data-reactid="25"><div data-reactid="26"><p>You may want to create a Node module that is also an executable. The convention is to create two files, one for lib and the other for bin, but I think it&#39;s OK for simple modules.</p>
<p>To achieve it, you need to detect whether it&#39;s executed as an entry point. According to <a href="https://nodejs.org/api/modules.html#modules_accessing_the_main_module">the official documentation of Node</a>:</p>
<blockquote>
<p>When a file is run directly from Node.js, <code>require.main</code> is set to its module. That means that you can determine whether a file has been run directly by testing</p>
<pre><code class="hljs undefined">require.main === module</code></pre></blockquote>
<p>For example:</p>
<pre><code class="hljs js">#!/usr/bin/env node

function sum(a, b) {
  return a + b;
}

module.exports = sum;

if (require.main === module) {
  var a = parseInt(process.argv[2], 10);
  var b = parseInt(process.argv[3], 10);
  console.log(sum(a, b));
}</code></pre><p>Then you can use it as an executable and a module.</p>
<pre><code class="hljs sh">$ node sum.js <span class="hljs-number">3</span> <span class="hljs-number">4</span>
<span class="hljs-number">7</span>
$ node
&gt; require(<span class="hljs-string">'./sum'</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
<span class="hljs-number">7</span></code></pre></div></div></div><div class="post" data-reactid="27"><div class="post-header" data-reactid="28"><h1 class="title" data-reactid="29"><a href="/blog/2015/10/18/color-prompt-by-exit-code/" data-reactid="30">Color prompt by exit code</a></h1><div class="meta" data-reactid="31"><!-- react-text: 32 -->@<!-- /react-text --><span class="date" data-reactid="33">2015-10-18 19:11</span><!-- react-text: 34 --> - <!-- /react-text --><span class="category" data-reactid="35">Bash</span></div></div><div class="content" data-reactid="36"><div data-reactid="37"><p>The idea of customizing bash prompt hooked me a few months ago. I tried a few crazy things like <a href="https://github.com/shuhei/dotfiles/commit/a45d8c88d4c02737dad397b56624895bb715f5b5">showing random emojis</a> and finally settled down with just showing the current directory, git branch and status.</p>
<p>At <a href="http://nodejs.connpass.com/event/20646/">Tokyo Node Gakuen #18</a> on October 8th, <a href="https://twitter.com/yosuke_furukawa">@yosuke_furukawa</a> <a href="https://speakerdeck.com/yosuke_furukawa/node-dot-js-v4-falsehua-number-tng18">talked about Node.js v4.0</a>. Aside from the well-organized and informative talk, I found another interesting thing at his demo. His terminal prompt <em>turned red when a command failed</em>.</p>
<p>It looked pretty and useful. So I emulated it.</p>
<p><img src="/images/prompt-exit-code.gif" alt="Changing prompt color "></p>
<p>The code in <code>.bash_profile</code> is pretty straightforward. It changes the prompt color depending on whether the exit code is 0 or not. The only one trick is to capture the exit code at the very first line of the prompt command to prevent it from being changed in prior lines.</p>
<pre><code class="hljs sh"><span class="hljs-comment"># Colors</span>
light_green=<span class="hljs-string">"\[\e[1;32m\]"</span>
light_red=<span class="hljs-string">"\[\e[1;31m\]"</span>
yellow=<span class="hljs-string">"\[\e[0;33m\]"</span>
gray=<span class="hljs-string">"\[\e[0;37m\]"</span>
reset=<span class="hljs-string">"\[\e[m\]"</span>

<span class="hljs-comment"># Customize prompt</span>
<span class="hljs-function"><span class="hljs-title">prompt_command</span></span>() {
  <span class="hljs-built_in">local</span> status=<span class="hljs-string">"$?"</span>
  <span class="hljs-built_in">local</span> status_color=<span class="hljs-string">""</span>
  <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$status</span> != <span class="hljs-number">0</span> ]; <span class="hljs-keyword">then</span>
    status_color=<span class="hljs-variable">$light_red</span>
  <span class="hljs-keyword">else</span>
    status_color=<span class="hljs-variable">$light_green</span>
  <span class="hljs-keyword">fi</span>
  <span class="hljs-built_in">export</span> PS1=<span class="hljs-string">"[<span class="hljs-variable">${yellow}</span>\w<span class="hljs-variable">${reset}</span>]<span class="hljs-variable">${gray}</span><span class="hljs-variable">$(__git_ps1)</span><span class="hljs-variable">${reset}</span> <span class="hljs-variable">${status_color}</span>Î»<span class="hljs-variable">${reset}</span> "</span>
}
<span class="hljs-built_in">export</span> GIT_PS1_SHOWDIRTYSTATE=<span class="hljs-number">1</span>
<span class="hljs-built_in">export</span> PROMPT_COMMAND=prompt_commandsh</code></pre><p>One of the advantages of attending real events over just browsing slides online is being able to take a peek of other people&#39;s dev environments. Looking forward to seeing more cool stuff on upcoming events like <a href="http://nodefest.jp/2015/">Tokyo Node Fest 2015</a>.</p>
</div></div></div><div class="post" data-reactid="38"><div class="post-header" data-reactid="39"><h1 class="title" data-reactid="40"><a href="/blog/2015/09/26/speed-up-your-rspec-tests-by-reviewing-factory-girl/" data-reactid="41">Speed up your RSpec tests by reviewing Factory Girl</a></h1><div class="meta" data-reactid="42"><!-- react-text: 43 -->@<!-- /react-text --><span class="date" data-reactid="44">2015-09-26 09:23</span><!-- react-text: 45 --> - <!-- /react-text --><span class="category" data-reactid="46">Ruby</span><!-- react-text: 47 -->, <!-- /react-text --><span class="category" data-reactid="48">Rails</span></div></div><div class="content" data-reactid="49"><div data-reactid="50"><p><a href="https://github.com/thoughtbot/factory_girl">Factory Girl</a> is a great tool that makes test data creation easier. However, if you don&#39;t use it properly, it may imperceptibly slow down your tests.</p>
<p>In this post, I will walk through some caveats that I stumbled upon in my current project. They could be applied not only to RSpec but I will use RSpec as an example.</p>
<h2 id="measure-measure-measure-">Measure! Measure! Measure!</h2>
<blockquote>
<p>What gets measured gets managed.</p>
<p><cite>Peter Drucker</cite></p>
</blockquote>
<p>First of all, we want to know which tests take most of the times. RSpec has <code>--profile</code>/<code>-p</code> option for the very purpose.</p>
<pre><code class="hljs sh">$ rspec --help
<span class="hljs-comment"># ...</span>
    -p, --[no-]profile [COUNT]       Enable profiling of examples and list the slowest examples (default: <span class="hljs-number">10</span>).
<span class="hljs-comment"># ...</span></code></pre><p>Let&#39;s measure your tests with it.</p>
<pre><code class="hljs sh"><span class="hljs-comment"># Run all specs with profiling.</span>
bin/rspec -p

<span class="hljs-comment"># Run specific spec file with profiling.</span>
bin/rspec spec/models/article_spec.rb -p</code></pre><p>It shows the slowest examples and groups. They should be the good point to start with.</p>
<h2 id="database-writes-are-slow">Database writes are slow</h2>
<p>There are many potential causes that slow down your tests. External API calls, file access, database access and etc. Among them, I would like to focus on database writes in this post because they are ubiquitous and relatively slow.</p>
<p>You could use mocks/stubs to completely avoid touching database. However, you may have a certain amount of code that touches database. I believe it&#39;s better to find database-related bugs with a bit slow tests than finding them on production that were overlooked by lightning-fast tests.</p>
<p>One of the Rails&#39; greatest features is that we can easily write tests that involves database queries. It&#39;s too good not to use it at all.</p>
<p>Before you consider parallel execution of tests that may introduce other complexity, you still have something to do.</p>
<h2 id="sample-project">Sample project</h2>
<p>Let&#39;s say we have a blog application with the following models:</p>
<pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  has_many <span class="hljs-symbol">:articles</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Article</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  belongs_to <span class="hljs-symbol">:author</span>
  has_many <span class="hljs-symbol">:comments</span>

  validates <span class="hljs-symbol">:author</span>, <span class="hljs-symbol">presence:</span> <span class="hljs-keyword">true</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comment</span> <span class="hljs-inheritance">&lt; <span class="hljs-parent">ActiveRecord::Base</span></span></span>
  belongs_to <span class="hljs-symbol">:article</span>

  validates <span class="hljs-symbol">:article</span>, <span class="hljs-symbol">presence:</span> <span class="hljs-keyword">true</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edited?</span></span>
    created_at &lt; updated_at
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><p>and factories:</p>
<pre><code class="hljs ruby"><span class="hljs-constant">FactoryGirl</span>.define <span class="hljs-keyword">do</span>
  factory <span class="hljs-symbol">:author</span> <span class="hljs-keyword">do</span>
    first_name <span class="hljs-string">'Shuhei'</span>
    last_name <span class="hljs-string">'Kagawa'</span>
  <span class="hljs-keyword">end</span>

  factory <span class="hljs-symbol">:article</span> <span class="hljs-keyword">do</span>
    author
    title <span class="hljs-string">'Rails on Rails'</span>
    body <span class="hljs-string">'If you created an application that manages railway rails with the Rails framework, its name would be Rails on Rails...'</span>
  <span class="hljs-keyword">end</span>

  factory <span class="hljs-symbol">:comment</span> <span class="hljs-keyword">do</span>
    article
    commenter <span class="hljs-string">'Railer'</span>
    body <span class="hljs-string">'Great post!'</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><h2 id="factorygirl-build-creates-associations">FactoryGirl.build creates associations</h2>
<p>Let&#39;s review Factory Girl&#39;s <code>create</code> and <code>build</code>. <a href="http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#create-instance_method"><code>create</code></a> instantiates an model saving it into the database just like <code>ActiveRecord::Base.create</code> does. <a href="http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#build-instance_method"><code>build</code></a> only instantiates an model without saving it just like <code>ActiveRecord::Base.new</code> does.</p>
<p>The following usage of <code>FactoryGirl.build</code> seems harmful. <code>build</code> doesn&#39;t save a <code>Comment</code> into the database while <code>create</code> does, right?</p>
<pre><code class="hljs ruby">describe <span class="hljs-constant">Comment</span>
  describe <span class="hljs-string">'#edited?'</span> <span class="hljs-keyword">do</span>
    it <span class="hljs-string">'returns true if updated after creation'</span> <span class="hljs-keyword">do</span>
      now = <span class="hljs-constant">Time</span>.zone.now
      comment = <span class="hljs-constant">FactoryGirl</span>.build(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">created_at:</span> now - <span class="hljs-number">1</span>.minute, <span class="hljs-symbol">updated_at:</span> now)

      expect(comment).to be_edited
    <span class="hljs-keyword">end</span>

    it <span class="hljs-string">'returns false right after creation'</span> <span class="hljs-keyword">do</span>
      now = <span class="hljs-constant">Time</span>.zone.now
      comment = <span class="hljs-constant">FactoryGirl</span>.build(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">created_at:</span> now, <span class="hljs-symbol">updated_at:</span> now)

      expect(comment).not_to be_edited
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><p>However, <code>build</code> actually saves the model&#39;s associations, <code>article</code> and <code>author</code> created by <code>article</code> in this case, into the database <a href="http://www.rubydoc.info/gems/factory_girl/file/GETTING_STARTED.md#Associations">unless you give <code>strategy: :build</code> option in the factory</a>. So <code>build</code> actually creates all its ancestor models, which can be a huge performance penalty if called plenty of times.</p>
<p>To avoid this behavior, you can use <a href="http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#build_stubbed-instance_method"><code>FactoryGirl.build_stubbed</code></a> instead of <code>build</code>. It builds all associations and don&#39;t save them into the database.</p>
<pre><code class="hljs ruby">comment = <span class="hljs-constant">FactoryGirl</span>.build_stubbed(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">created_at:</span> now - <span class="hljs-number">1</span>.minute, <span class="hljs-symbol">updated_at:</span> now)</code></pre><p>In this case, you even don&#39;t need to use Factory Girl because the <code>edited?</code> method doesn&#39;t involve associations. The following just works fine:</p>
<pre><code class="hljs ruby">comment = <span class="hljs-constant">Comment</span>.new(<span class="hljs-symbol">created_at:</span> now - <span class="hljs-number">1</span>.minute, <span class="hljs-symbol">updated_at:</span> now)</code></pre><p>Here is another case where unnecessary <code>post</code> is created by <code>build(:comment)</code>.</p>
<pre><code class="hljs ruby">post = <span class="hljs-constant">FactoryGirl</span>.create(<span class="hljs-symbol">:post</span>)
post.comments &lt;&lt; <span class="hljs-constant">FactoryGirl</span>.build(<span class="hljs-symbol">:comment</span>)</code></pre><p>You could do:</p>
<pre><code class="hljs ruby">post = <span class="hljs-constant">FactoryGirl</span>.create(<span class="hljs-symbol">:post</span>)
post.comments &lt;&lt; <span class="hljs-constant">FactoryGirl</span>.build(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">post:</span> <span class="hljs-keyword">nil</span>)

<span class="hljs-comment"># or</span>

post = <span class="hljs-constant">FactoryGirl</span>.create(<span class="hljs-symbol">:post</span>)
<span class="hljs-constant">FactoryGirl</span>.create(<span class="hljs-symbol">:comment</span>, <span class="hljs-symbol">post:</span> post)</code></pre><h2 id="review-your-association-chain">Review your association chain</h2>
<p>There is also a case where you intentionally use <code>FactoryGirl.create</code> and create unused objects. Let&#39;s think about <code>Blog</code> model that has multiple authors and multiple posts.</p>
<pre><code class="hljs ruby"><span class="hljs-constant">FactoryGirl</span>.define <span class="hljs-keyword">do</span>
  factory <span class="hljs-symbol">:blog</span> <span class="hljs-keyword">do</span>
  <span class="hljs-keyword">end</span>

  factory <span class="hljs-symbol">:author</span> <span class="hljs-keyword">do</span>
    blog
  <span class="hljs-keyword">end</span>

  factory <span class="hljs-symbol">:post</span> <span class="hljs-keyword">do</span>
    author
    blog
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></code></pre><p>With the setup above, <code>FactoryGirl.create(:post)</code> <strong>creates blog twice</strong>, once in the <code>post</code> factory and once in the <code>author</code> factory. Not only is it redundant, but also it may introduce data inconsistency because the two <code>blog</code> instances are different.</p>
<p>The <code>post</code> factory could reuse the <code>author</code>&#39;s <code>blog</code>.</p>
<pre><code class="hljs ruby">factory <span class="hljs-symbol">:post</span> <span class="hljs-keyword">do</span>
  author
  blog { author.blog }
<span class="hljs-keyword">end</span></code></pre><h2 id="summary">Summary</h2>
<p>To recap, there are things to consider before you stub everything or start considering parallel execution of tests. Imagine what Factory Girl exactly does and review your tests and factories. You will be able to speed up your tests for relatively cheaper cost.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://github.com/thoughtbot/factory_girl">Factory Girl</a></li>
<li><a href="https://robots.thoughtbot.com/speed-up-tests-by-selectively-avoiding-factory-girl">Speed Up Tests by Selectively Avoiding Factory Girl</a></li>
<li><a href="https://robots.thoughtbot.com/use-factory-girls-build-stubbed-for-a-faster-test">Use Factory Girl&#39;s build_stubbed for a Faster Test Suite</a></li>
</ul>
</div></div></div><ul class="pagination" data-reactid="51"><li class="pagination__prev-page" data-reactid="52"><a href="/blog/pages/3/" data-reactid="53">Newer Posts</a></li><li class="pagination__archives" data-reactid="54"><a href="/blog/archives/" data-reactid="55">Archives</a></li><li class="pagination__next-page" data-reactid="56"><a href="/blog/pages/5/" data-reactid="57">Older Posts</a></li></ul></div></div><footer class="footer" data-reactid="58"><!-- react-text: 59 -->Â© <!-- /react-text --><!-- react-text: 60 -->Shuhei Kagawa<!-- /react-text --></footer></div></div>
        <script><!--
          window.__PRELOADED_PROPS__ = {"site":{"title":"Shuhei Kagawa","author":"Shuhei Kagawa","perPage":3,"newPageExtension":"markdown","blogDir":"blog","sourceDir":"source","layoutDir":"_layouts","postDir":"_posts"},"posts":[{"layout":"post","title":"Node.js executable module","date":"2015-10-25 22:42","comments":true,"categories":["JavaScript"],"url":"/blog/2015/10/25/node-executable-module/","content":"<p>You may want to create a Node module that is also an executable. The convention is to create two files, one for lib and the other for bin, but I think it&#39;s OK for simple modules.</p>\n<p>To achieve it, you need to detect whether it&#39;s executed as an entry point. According to <a href=\"https://nodejs.org/api/modules.html#modules_accessing_the_main_module\">the official documentation of Node</a>:</p>\n<blockquote>\n<p>When a file is run directly from Node.js, <code>require.main</code> is set to its module. That means that you can determine whether a file has been run directly by testing</p>\n<pre><code class=\"hljs undefined\">require.main === module</code></pre></blockquote>\n<p>For example:</p>\n<pre><code class=\"hljs js\">#!/usr/bin/env node\n\nfunction sum(a, b) {\n  return a + b;\n}\n\nmodule.exports = sum;\n\nif (require.main === module) {\n  var a = parseInt(process.argv[2], 10);\n  var b = parseInt(process.argv[3], 10);\n  console.log(sum(a, b));\n}</code></pre><p>Then you can use it as an executable and a module.</p>\n<pre><code class=\"hljs sh\">$ node sum.js <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>\n<span class=\"hljs-number\">7</span>\n$ node\n&gt; require(<span class=\"hljs-string\">'./sum'</span>)(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\n<span class=\"hljs-number\">7</span></code></pre>"},{"layout":"post","title":"Color prompt by exit code","date":"2015-10-18 19:11","comments":true,"categories":["Bash"],"url":"/blog/2015/10/18/color-prompt-by-exit-code/","content":"<p>The idea of customizing bash prompt hooked me a few months ago. I tried a few crazy things like <a href=\"https://github.com/shuhei/dotfiles/commit/a45d8c88d4c02737dad397b56624895bb715f5b5\">showing random emojis</a> and finally settled down with just showing the current directory, git branch and status.</p>\n<p>At <a href=\"http://nodejs.connpass.com/event/20646/\">Tokyo Node Gakuen #18</a> on October 8th, <a href=\"https://twitter.com/yosuke_furukawa\">@yosuke_furukawa</a> <a href=\"https://speakerdeck.com/yosuke_furukawa/node-dot-js-v4-falsehua-number-tng18\">talked about Node.js v4.0</a>. Aside from the well-organized and informative talk, I found another interesting thing at his demo. His terminal prompt <em>turned red when a command failed</em>.</p>\n<p>It looked pretty and useful. So I emulated it.</p>\n<p><img src=\"/images/prompt-exit-code.gif\" alt=\"Changing prompt color \"></p>\n<p>The code in <code>.bash_profile</code> is pretty straightforward. It changes the prompt color depending on whether the exit code is 0 or not. The only one trick is to capture the exit code at the very first line of the prompt command to prevent it from being changed in prior lines.</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># Colors</span>\nlight_green=<span class=\"hljs-string\">\"\\[\\e[1;32m\\]\"</span>\nlight_red=<span class=\"hljs-string\">\"\\[\\e[1;31m\\]\"</span>\nyellow=<span class=\"hljs-string\">\"\\[\\e[0;33m\\]\"</span>\ngray=<span class=\"hljs-string\">\"\\[\\e[0;37m\\]\"</span>\nreset=<span class=\"hljs-string\">\"\\[\\e[m\\]\"</span>\n\n<span class=\"hljs-comment\"># Customize prompt</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">prompt_command</span></span>() {\n  <span class=\"hljs-built_in\">local</span> status=<span class=\"hljs-string\">\"$?\"</span>\n  <span class=\"hljs-built_in\">local</span> status_color=<span class=\"hljs-string\">\"\"</span>\n  <span class=\"hljs-keyword\">if</span> [ <span class=\"hljs-variable\">$status</span> != <span class=\"hljs-number\">0</span> ]; <span class=\"hljs-keyword\">then</span>\n    status_color=<span class=\"hljs-variable\">$light_red</span>\n  <span class=\"hljs-keyword\">else</span>\n    status_color=<span class=\"hljs-variable\">$light_green</span>\n  <span class=\"hljs-keyword\">fi</span>\n  <span class=\"hljs-built_in\">export</span> PS1=<span class=\"hljs-string\">\"[<span class=\"hljs-variable\">${yellow}</span>\\w<span class=\"hljs-variable\">${reset}</span>]<span class=\"hljs-variable\">${gray}</span><span class=\"hljs-variable\">$(__git_ps1)</span><span class=\"hljs-variable\">${reset}</span> <span class=\"hljs-variable\">${status_color}</span>Î»<span class=\"hljs-variable\">${reset}</span> \"</span>\n}\n<span class=\"hljs-built_in\">export</span> GIT_PS1_SHOWDIRTYSTATE=<span class=\"hljs-number\">1</span>\n<span class=\"hljs-built_in\">export</span> PROMPT_COMMAND=prompt_commandsh</code></pre><p>One of the advantages of attending real events over just browsing slides online is being able to take a peek of other people&#39;s dev environments. Looking forward to seeing more cool stuff on upcoming events like <a href=\"http://nodefest.jp/2015/\">Tokyo Node Fest 2015</a>.</p>\n"},{"layout":"post","title":"Speed up your RSpec tests by reviewing Factory Girl","date":"2015-09-26 09:23","comments":true,"categories":["Ruby","Rails"],"url":"/blog/2015/09/26/speed-up-your-rspec-tests-by-reviewing-factory-girl/","content":"<p><a href=\"https://github.com/thoughtbot/factory_girl\">Factory Girl</a> is a great tool that makes test data creation easier. However, if you don&#39;t use it properly, it may imperceptibly slow down your tests.</p>\n<p>In this post, I will walk through some caveats that I stumbled upon in my current project. They could be applied not only to RSpec but I will use RSpec as an example.</p>\n<h2 id=\"measure-measure-measure-\">Measure! Measure! Measure!</h2>\n<blockquote>\n<p>What gets measured gets managed.</p>\n<p><cite>Peter Drucker</cite></p>\n</blockquote>\n<p>First of all, we want to know which tests take most of the times. RSpec has <code>--profile</code>/<code>-p</code> option for the very purpose.</p>\n<pre><code class=\"hljs sh\">$ rspec --help\n<span class=\"hljs-comment\"># ...</span>\n    -p, --[no-]profile [COUNT]       Enable profiling of examples and list the slowest examples (default: <span class=\"hljs-number\">10</span>).\n<span class=\"hljs-comment\"># ...</span></code></pre><p>Let&#39;s measure your tests with it.</p>\n<pre><code class=\"hljs sh\"><span class=\"hljs-comment\"># Run all specs with profiling.</span>\nbin/rspec -p\n\n<span class=\"hljs-comment\"># Run specific spec file with profiling.</span>\nbin/rspec spec/models/article_spec.rb -p</code></pre><p>It shows the slowest examples and groups. They should be the good point to start with.</p>\n<h2 id=\"database-writes-are-slow\">Database writes are slow</h2>\n<p>There are many potential causes that slow down your tests. External API calls, file access, database access and etc. Among them, I would like to focus on database writes in this post because they are ubiquitous and relatively slow.</p>\n<p>You could use mocks/stubs to completely avoid touching database. However, you may have a certain amount of code that touches database. I believe it&#39;s better to find database-related bugs with a bit slow tests than finding them on production that were overlooked by lightning-fast tests.</p>\n<p>One of the Rails&#39; greatest features is that we can easily write tests that involves database queries. It&#39;s too good not to use it at all.</p>\n<p>Before you consider parallel execution of tests that may introduce other complexity, you still have something to do.</p>\n<h2 id=\"sample-project\">Sample project</h2>\n<p>Let&#39;s say we have a blog application with the following models:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Author</span> <span class=\"hljs-inheritance\">&lt; <span class=\"hljs-parent\">ActiveRecord::Base</span></span></span>\n  has_many <span class=\"hljs-symbol\">:articles</span>\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Article</span> <span class=\"hljs-inheritance\">&lt; <span class=\"hljs-parent\">ActiveRecord::Base</span></span></span>\n  belongs_to <span class=\"hljs-symbol\">:author</span>\n  has_many <span class=\"hljs-symbol\">:comments</span>\n\n  validates <span class=\"hljs-symbol\">:author</span>, <span class=\"hljs-symbol\">presence:</span> <span class=\"hljs-keyword\">true</span>\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Comment</span> <span class=\"hljs-inheritance\">&lt; <span class=\"hljs-parent\">ActiveRecord::Base</span></span></span>\n  belongs_to <span class=\"hljs-symbol\">:article</span>\n\n  validates <span class=\"hljs-symbol\">:article</span>, <span class=\"hljs-symbol\">presence:</span> <span class=\"hljs-keyword\">true</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">edited?</span></span>\n    created_at &lt; updated_at\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre><p>and factories:</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-constant\">FactoryGirl</span>.define <span class=\"hljs-keyword\">do</span>\n  factory <span class=\"hljs-symbol\">:author</span> <span class=\"hljs-keyword\">do</span>\n    first_name <span class=\"hljs-string\">'Shuhei'</span>\n    last_name <span class=\"hljs-string\">'Kagawa'</span>\n  <span class=\"hljs-keyword\">end</span>\n\n  factory <span class=\"hljs-symbol\">:article</span> <span class=\"hljs-keyword\">do</span>\n    author\n    title <span class=\"hljs-string\">'Rails on Rails'</span>\n    body <span class=\"hljs-string\">'If you created an application that manages railway rails with the Rails framework, its name would be Rails on Rails...'</span>\n  <span class=\"hljs-keyword\">end</span>\n\n  factory <span class=\"hljs-symbol\">:comment</span> <span class=\"hljs-keyword\">do</span>\n    article\n    commenter <span class=\"hljs-string\">'Railer'</span>\n    body <span class=\"hljs-string\">'Great post!'</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre><h2 id=\"factorygirl-build-creates-associations\">FactoryGirl.build creates associations</h2>\n<p>Let&#39;s review Factory Girl&#39;s <code>create</code> and <code>build</code>. <a href=\"http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#create-instance_method\"><code>create</code></a> instantiates an model saving it into the database just like <code>ActiveRecord::Base.create</code> does. <a href=\"http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#build-instance_method\"><code>build</code></a> only instantiates an model without saving it just like <code>ActiveRecord::Base.new</code> does.</p>\n<p>The following usage of <code>FactoryGirl.build</code> seems harmful. <code>build</code> doesn&#39;t save a <code>Comment</code> into the database while <code>create</code> does, right?</p>\n<pre><code class=\"hljs ruby\">describe <span class=\"hljs-constant\">Comment</span>\n  describe <span class=\"hljs-string\">'#edited?'</span> <span class=\"hljs-keyword\">do</span>\n    it <span class=\"hljs-string\">'returns true if updated after creation'</span> <span class=\"hljs-keyword\">do</span>\n      now = <span class=\"hljs-constant\">Time</span>.zone.now\n      comment = <span class=\"hljs-constant\">FactoryGirl</span>.build(<span class=\"hljs-symbol\">:comment</span>, <span class=\"hljs-symbol\">created_at:</span> now - <span class=\"hljs-number\">1</span>.minute, <span class=\"hljs-symbol\">updated_at:</span> now)\n\n      expect(comment).to be_edited\n    <span class=\"hljs-keyword\">end</span>\n\n    it <span class=\"hljs-string\">'returns false right after creation'</span> <span class=\"hljs-keyword\">do</span>\n      now = <span class=\"hljs-constant\">Time</span>.zone.now\n      comment = <span class=\"hljs-constant\">FactoryGirl</span>.build(<span class=\"hljs-symbol\">:comment</span>, <span class=\"hljs-symbol\">created_at:</span> now, <span class=\"hljs-symbol\">updated_at:</span> now)\n\n      expect(comment).not_to be_edited\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre><p>However, <code>build</code> actually saves the model&#39;s associations, <code>article</code> and <code>author</code> created by <code>article</code> in this case, into the database <a href=\"http://www.rubydoc.info/gems/factory_girl/file/GETTING_STARTED.md#Associations\">unless you give <code>strategy: :build</code> option in the factory</a>. So <code>build</code> actually creates all its ancestor models, which can be a huge performance penalty if called plenty of times.</p>\n<p>To avoid this behavior, you can use <a href=\"http://www.rubydoc.info/gems/factory_girl/FactoryGirl/Syntax/Methods#build_stubbed-instance_method\"><code>FactoryGirl.build_stubbed</code></a> instead of <code>build</code>. It builds all associations and don&#39;t save them into the database.</p>\n<pre><code class=\"hljs ruby\">comment = <span class=\"hljs-constant\">FactoryGirl</span>.build_stubbed(<span class=\"hljs-symbol\">:comment</span>, <span class=\"hljs-symbol\">created_at:</span> now - <span class=\"hljs-number\">1</span>.minute, <span class=\"hljs-symbol\">updated_at:</span> now)</code></pre><p>In this case, you even don&#39;t need to use Factory Girl because the <code>edited?</code> method doesn&#39;t involve associations. The following just works fine:</p>\n<pre><code class=\"hljs ruby\">comment = <span class=\"hljs-constant\">Comment</span>.new(<span class=\"hljs-symbol\">created_at:</span> now - <span class=\"hljs-number\">1</span>.minute, <span class=\"hljs-symbol\">updated_at:</span> now)</code></pre><p>Here is another case where unnecessary <code>post</code> is created by <code>build(:comment)</code>.</p>\n<pre><code class=\"hljs ruby\">post = <span class=\"hljs-constant\">FactoryGirl</span>.create(<span class=\"hljs-symbol\">:post</span>)\npost.comments &lt;&lt; <span class=\"hljs-constant\">FactoryGirl</span>.build(<span class=\"hljs-symbol\">:comment</span>)</code></pre><p>You could do:</p>\n<pre><code class=\"hljs ruby\">post = <span class=\"hljs-constant\">FactoryGirl</span>.create(<span class=\"hljs-symbol\">:post</span>)\npost.comments &lt;&lt; <span class=\"hljs-constant\">FactoryGirl</span>.build(<span class=\"hljs-symbol\">:comment</span>, <span class=\"hljs-symbol\">post:</span> <span class=\"hljs-keyword\">nil</span>)\n\n<span class=\"hljs-comment\"># or</span>\n\npost = <span class=\"hljs-constant\">FactoryGirl</span>.create(<span class=\"hljs-symbol\">:post</span>)\n<span class=\"hljs-constant\">FactoryGirl</span>.create(<span class=\"hljs-symbol\">:comment</span>, <span class=\"hljs-symbol\">post:</span> post)</code></pre><h2 id=\"review-your-association-chain\">Review your association chain</h2>\n<p>There is also a case where you intentionally use <code>FactoryGirl.create</code> and create unused objects. Let&#39;s think about <code>Blog</code> model that has multiple authors and multiple posts.</p>\n<pre><code class=\"hljs ruby\"><span class=\"hljs-constant\">FactoryGirl</span>.define <span class=\"hljs-keyword\">do</span>\n  factory <span class=\"hljs-symbol\">:blog</span> <span class=\"hljs-keyword\">do</span>\n  <span class=\"hljs-keyword\">end</span>\n\n  factory <span class=\"hljs-symbol\">:author</span> <span class=\"hljs-keyword\">do</span>\n    blog\n  <span class=\"hljs-keyword\">end</span>\n\n  factory <span class=\"hljs-symbol\">:post</span> <span class=\"hljs-keyword\">do</span>\n    author\n    blog\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span></code></pre><p>With the setup above, <code>FactoryGirl.create(:post)</code> <strong>creates blog twice</strong>, once in the <code>post</code> factory and once in the <code>author</code> factory. Not only is it redundant, but also it may introduce data inconsistency because the two <code>blog</code> instances are different.</p>\n<p>The <code>post</code> factory could reuse the <code>author</code>&#39;s <code>blog</code>.</p>\n<pre><code class=\"hljs ruby\">factory <span class=\"hljs-symbol\">:post</span> <span class=\"hljs-keyword\">do</span>\n  author\n  blog { author.blog }\n<span class=\"hljs-keyword\">end</span></code></pre><h2 id=\"summary\">Summary</h2>\n<p>To recap, there are things to consider before you stub everything or start considering parallel execution of tests. Imagine what Factory Girl exactly does and review your tests and factories. You will be able to speed up your tests for relatively cheaper cost.</p>\n<h2 id=\"references\">References</h2>\n<ul>\n<li><a href=\"https://github.com/thoughtbot/factory_girl\">Factory Girl</a></li>\n<li><a href=\"https://robots.thoughtbot.com/speed-up-tests-by-selectively-avoiding-factory-girl\">Speed Up Tests by Selectively Avoiding Factory Girl</a></li>\n<li><a href=\"https://robots.thoughtbot.com/use-factory-girls-build-stubbed-for-a-faster-test\">Use Factory Girl&#39;s build_stubbed for a Faster Test Suite</a></li>\n</ul>\n"}],"prevPage":"/blog/pages/3/","title":"Page 4 - Shuhei Kagawa","nextPage":"/blog/pages/5/"};
        --></script>
        <script src="/js/index.js"></script>
      </body>
    </html>