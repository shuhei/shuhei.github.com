<!doctype html><html lang="en"><head><meta charset="utf-8"><link rel="preload" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Libre+Baskerville:ital@0;1&amp;family=Libre+Franklin:wght@700&amp;family=DM+Mono" as="style"><link rel="preload" href="https://fonts.gstatic.com/s/librebaskerville/v9/kmKnZrc3Hgbbcjq75U4uslyuy4kn0qNZaxMaC82U.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="https://fonts.gstatic.com/s/librefranklin/v6/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkANDPTedX18mE.woff" as="font" crossorigin="anonymous"><link rel="preload" href="https://fonts.gstatic.com/s/dmmono/v3/aFTU7PB1QTsUX8KYthqQBK6PYK0.woff2" as="font" crossorigin="anonymous"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><meta name="viewport" content="width=device-width,initial-scale=1"><title>Shuhei Kagawa</title><link rel="icon" sizes="16x16 32x32 48x48" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="RSS Feed for shuheikagawa.com" href="/blog/feed/rss.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-309586-8', 'shuheikagawa.com');
      ga('send', 'pageview');</script><style>:root{--bg-color:#f9f9f9;--text-color:#222;--highlight-color:#095ae8;--code-text-color:var(--code-mono-1);--code-bg-color:#fff;--syntax-hue:230;--syntax-saturation:1%;--syntax-brightness:100%;--code-mono-1:hsl(var(--syntax-hue), 8%, 24%);--code-mono-2:hsl(var(--syntax-hue), 6%, 44%);--code-mono-3:hsl(var(--syntax-hue), 4%, 64%);--code-hue-1:hsl(198, 99%, 37%);--code-hue-2:hsl(221, 76%, 47%);--code-hue-3:hsl(301, 63%, 40%);--code-hue-4:hsl(119, 72%, 31%);--code-hue-5:hsl(5, 68%, 48%);--code-hue-5-2:hsl(344, 84%, 43%);--code-hue-6:hsl(41, 99%, 30%);--code-hue-6-2:hsl(41, 99%, 30%);--body-font-family:"Libre Baskerville",serif;--heading-font-family:"Libre Franklin",sans-serif;--code-font-family:"DM Mono",monospace}body{font-family:"Libre Baskerville",serif;font-family:var(--body-font-family);background:#f9f9f9;background:var(--bg-color);color:#222;color:var(--text-color);padding:0;margin:0;font-size:16px;line-height:1.9}.container{width:700px;padding:0 20px;margin:0 auto}a{color:#095ae8;color:var(--highlight-color);transition:color .5s ease;text-decoration:none}a:hover{text-decoration:underline}.header{padding:1.5em 0 1em;display:flex}.header__title{margin:0 10px 0 0;flex-grow:1;font-size:1em;font-weight:400}.header__title a{color:#222;color:var(--text-color)}.header__nav{flex-grow:0}.menu{list-style-position:outside;list-style-type:none;padding:0;margin:0;text-align:right}.menu__item{display:inline-block;padding:0 0 0 .7em}.menu__item a{color:#222;color:var(--text-color)}.footer{padding:3em 0 4em;text-align:center}.title{font-family:"Libre Franklin",sans-serif;font-family:var(--heading-font-family);font-size:3em;margin:0 0 .2em;line-height:1.1}.title a{color:#222;color:var(--text-color);text-decoration:none}.post,.post-list{padding:1.7em 0 1.25em}.post:not(:first-child):before{content:"* * *";font-family:"Libre Franklin",sans-serif;font-family:var(--heading-font-family);font-weight:700;font-size:4em;display:block;margin:.2em auto .6em;text-align:center;line-height:1}.post .meta{font-size:.75em}.post-list .title{margin-bottom:10px}.post-list-item{line-height:1.6em;padding:10px 0;display:flex}.post-list-item__date{font-size:.8em;width:8em;flex-shrink:0}.post-list-item__title{font-size:1.3em;margin:0;font-family:"Libre Franklin",sans-serif;font-family:var(--heading-font-family);font-weight:700}.post-list-item__title a{text-decoration:none;color:#222;color:var(--text-color)}.content h2,.content h3,.content h4,.content h5,.content h6{font-family:"Libre Franklin",sans-serif;font-family:var(--heading-font-family);margin:1em 0 0 0}.content h2{font-size:2.2em;line-height:1.1}.content h3{font-size:1.6em;line-height:1.3}.content h4{font-size:1.2em}.content img{max-width:100%;height:auto}.content p{margin:1.15em 0}.img-wrapper{display:block;text-align:center}.comments{margin-bottom:3em}ol,ul{list-style-position:outside;padding-left:1.4em}.table-wrapper{overflow-x:auto;margin:1.15em 0}.table-wrapper table{border-collapse:collapse;margin:0;width:100%}tr{vertical-align:top}th{font-weight:400;text-align:left}tbody{border-top:1px solid #333;border-bottom:1px solid #333;padding:.5em 0}td,th{padding-right:1em}code{color:#383942;color:var(--code-text-color);background-color:#fff;background-color:var(--code-bg-color);font-size:.9em;font-family:"DM Mono",monospace;font-family:var(--code-font-family)}.code__filename{display:inline-block;margin-bottom:13px;padding:5px 10px;font-size:.85em;background-color:#666}.hljs{display:block;line-height:1.5em;padding:1em 20px;overflow-x:auto;-webkit-overflow-scrolling:touch;color:#383942;color:var(--code-text-color);background-color:#fff;background-color:var(--code-bg-color)}.hljs-comment,.hljs-quote{color:#696b76;color:var(--code-mono-2);font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a625a4;color:var(--code-hue-3)}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#cd3527;color:var(--code-hue-5)}.hljs-literal{color:#0083bb;color:var(--code-hue-1)}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#188716;color:var(--code-hue-4)}.hljs-built_in,.hljs-class .hljs-title{color:#986800;color:var(--code-hue-6-2)}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986800;color:var(--code-hue-6)}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#1c56d2;color:var(--code-hue-2)}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}blockquote{font-style:italic;padding:0 0 0 2em;margin:1.5em 0}blockquote p:first-child:before{content:open-quote;font-family:serif;font-size:3em;font-weight:700;line-height:.1em;margin-right:.2em;vertical-align:-.4em}blockquote cite{color:#999990}blockquote cite:before{content:"- "}.pagination{list-style-position:outside;list-style-type:none;padding:0;margin-top:20px;display:flex;justify-content:space-between}.pagination li{min-height:1em}.pagination a{text-decoration:none}.pagination__next-page,.pagination__prev-page{width:35%}.pagination__next-page{text-align:right}.pagination__archives{flex-grow:1;text-align:center}@media only screen and (max-width:767px){body{font-size:15px;line-height:1.65}.container{width:auto}.post,.post-list{padding-top:10px}.post-list-item{display:block}.hljs{margin-left:-20px;margin-right:-20px;padding:1.4em 20px;border-radius:0}li .hljs{margin-left:0}.img-wrapper{margin-left:-20px;margin-right:-20px}}</style><link rel="stylesheet" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Libre+Baskerville:ital@0;1&amp;family=Libre+Franklin:wght@700&amp;family=DM+Mono"><meta name="description" content="A personal website of Shuhei Kagawa. I write mostly on web technologies and life."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@shuheikagawa"><meta property="og:title" content="Shuhei Kagawa"><meta property="og:site_name" content="Shuhei Kagawa"><meta property="og:description" content="A personal website of Shuhei Kagawa. I write mostly on web technologies and life."></head><body><div class="container"><header class="header"><h1 class="header__title"><a href="/">Shuhei Kagawa</a></h1><nav class="header__nav"><ul class="menu"><li class="menu__item"><a href="/about/">About</a></li><li class="menu__item"><a href="/blog/archives/">All posts</a></li></ul></nav></header><div class="main"><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2019/10/08/migrating-from-bash-to-zsh/">Migrating from bash to zsh</a></h1><div class="meta"><span class="date">Oct 8, 2019</span> - zsh</div></div><div class="content"><div><p>A few days ago, I updated my Macbook Air to macOS Catalina. The installation took some time, but it was done when I got up the next morning. The applications that I use seemed to work fine on Catalina. But bash started complaining at the beginning of new sessions.</p><pre><code class="hljs console">The default interactive shell is now zsh.
To update your account to use zsh, please run `chsh -s /bin/zsh`.
For more details, please visit https://support.apple.com/kb/HT208050.
</code></pre><p>I asked whether I should migrate to zsh on Twitter. Three people said "yes" as if it was common sense. OK, let's migrate.</p><h2>Changing the default shell of tmux</h2><p>First, I followed the instruction from Apple.</p><pre><code class="hljs sh">chsh -s /bin/zsh
</code></pre><p>However, it didn't change the default shell of tmux. I restarted sessions in tmux, and restarted iTerm 2 and the tmux server. But tmux still started bash sessions. Why?</p><p>I googled. There was <a href="https://superuser.com/questions/253786/how-can-i-make-tmux-use-my-default-shell">a Q&amp;A for the exact problem</a> on superuser. The <code>default-command</code> option of tmux is the default shell. I had a hardcoded <code>bash</code> there! By the way, <code>reattach-to-user-namespace</code> is for sharing Mac's clipboard with tmux.</p><pre><code class="hljs">set-option -g default-command "reattach-to-user-namespace -l bash"
</code></pre><p>I updated it with <code>SHELL</code> environment variable so that I can migrate to any shell in the future!</p><pre><code class="hljs">set-option -g default-command "reattach-to-user-namespace -l ${SHELL}"
</code></pre><h2>Command prompt</h2><p>Then I installed <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a> and copied my <code>.bash_profile</code> to <code>.zshrc</code>. Most of the content of my <code>.bash_profile</code> were aliases and <code>PATH</code>s. They worked fine on zsh too.</p><p>But zsh has a different format for prompt. oh-my-zsh provides a lot of nice prompt themes, but I wanted to keep using the one that I had configured with bash. Let's migrate it to zsh.</p><p><s>oh-my-zsh has a directory for custom themes (<code>.oh-my-zsh/custom/themes</code>). I moved the <code>custom</code> directory to <a href="https://github.com/shuhei/dotfiles">my dotfiles repo</a> and symlinked it so that I can manage my custom theme with Git without forking oh-my-zsh itself.</s> [Update on Oct 24, 2019] I realized that this symlink approach prevents updates of oh-my-zsh because it modifies the files in the git local clone of oh-my-zsh. <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Customization">The official customization guide</a> recommends to use <code>ZSH_CUSTOM</code> variable to specify the location of a custom directory. Now I'm using <code>ZSH_CUSTOM</code> to point to a directory in my dotfiles repo.</p><p>Eventually, I came up with a theme like this:</p><p><span class="img-wrapper"><picture><source type="image/avif" srcset="/images/a4c4e21-607.avif 607w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><source type="image/webp" srcset="/images/a4c4e21-607.webp 607w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><img src="/images/a4c4e21-607.png" width="607" height="101" alt="my custom theme" loading="lazy" decoding="async"></picture></span></p><pre><code class="hljs bash">ZSH_THEME_GIT_PROMPT_PREFIX=<span class="hljs-string">"%{<span class="hljs-variable">$fg</span>[white]%}("</span>
ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="hljs-string">"%{<span class="hljs-variable">$fg</span>[white]%})%{<span class="hljs-variable">$reset_color</span>%}"</span>
ZSH_THEME_GIT_PROMPT_DIRTY=<span class="hljs-string">"*"</span>
ZSH_THEME_GIT_PROMPT_CLEAN=<span class="hljs-string">""</span>

<span class="hljs-comment"># %~ is the current working directory relative to the home directory</span>
PROMPT=<span class="hljs-string">'[$FG[228]%~%{$reset_color%}]'</span>
PROMPT+=<span class="hljs-string">' $(git_prompt_info)'</span>
PROMPT+=<span class="hljs-string">' %(?.$FG[154].$FG[009])€%{$reset_color%} '</span>
</code></pre><p>Each oh-my-zsh theme defines a variable called <code>PROMPT</code>. Aside from <a href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html">its syntax</a>, I was not sure how and when <code>PROMPT</code> was evaluated. In hindsight, it is a string that is built once when a session starts or <code>source .zshrc</code>. Every time a prompt is shown, <code>PROMPT</code> is evaluated, meaning escapes (starting with <code>%</code>) and variables in it are expanded.</p><h3>Colors</h3><p>At the beginning, I was baffled by how to specify colors. For example, the following <code>PROMPT</code> shows "some red text" in red.</p><pre><code class="hljs bash">PROMPT=<span class="hljs-string">'%{$fg[red]%}some red text%{$reset_color%}'</span>
</code></pre><p><code>$fg[red]</code> has the code that makes its following text red. <code>$reset_color</code> has the code that resets the color. The tricky part is that these codes need to be surrounded by <code>%{</code> and <code>%}</code> in <code>PROMPT</code>.</p><p><a href="https://github.com/zsh-users/zsh/blob/243e46998eb29665ec345e531b2d1bb6921ed578/Functions/Misc/colors#L97-L117">zsh provides handy variables for colors</a>.</p><ul><li><code>reset_color</code></li><li><code>fg</code>, <code>fg_bold</code>, <code>fg_no_bold</code>: They are associative arrays (similar to JavaScript objects).</li><li><code>bg</code>, <code>bg_bold</code>, <code>bg_no_bold</code></li></ul><p>Also, <a href="https://github.com/robbyrussell/oh-my-zsh/blob/b09aed9cc7e2099f3e7f2aa2632660bc510f3e35/lib/spectrum.zsh">oh-my-zsh provides 256 colors</a>.</p><ul><li><code>FX</code>: This has codes for text effects like <code>FX[underline]</code>.</li><li><code>FG</code>: 256 colors for foreground like <code>FG[102]</code>.</li><li><code>BG</code>: 256 colors for background like <code>BG[123]</code>.</li></ul><p><code>spectrum_ls</code> and <code>spectrum_bls</code> commands show you all the 256 colors! Note that values in <code>FX</code>, <code>FG</code> and <code>BG</code> are already surrounded by <code>%{</code> and <code>%}</code>, and we don't need to do it again.</p><p>We can examine those variables in the terminal.</p><pre><code class="hljs sh"><span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${fg[yellow]}</span>hello<span class="hljs-variable">${reset_color}</span> <span class="hljs-variable">${bg[green]}</span>world<span class="hljs-variable">${reset_color}</span>"</span>

<span class="hljs-comment"># `(kv)` extracts key values from an associative array.</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">${(kv)fg}</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">${(kv)FG}</span>
</code></pre><h3>Exit code</h3><p>With bash, <a href="/blog/2015/10/18/color-prompt-by-exit-code/">I had a trick to change the color of the prompt by the previous command's exit code</a>. How can I achieve this with zsh?</p><p><span class="img-wrapper"><picture><source type="image/avif" srcset="/images/8d720a49-557.avif 557w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><source type="image/webp" srcset="/images/8d720a49-557.webp 557w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><img src="/images/8d720a49-557.png" width="557" height="99" alt="Change color by exit code" loading="lazy" decoding="async"></picture></span></p><p>Surprisingly, <a href="https://stackoverflow.com/questions/4466245/customize-zshs-prompt-when-displaying-previous-command-exit-code">zsh prompt expression has a special syntax for switching prompt by exit code</a>. To be accurate, it's a combination of a ternary operator and <code>?</code> for exit code check.</p><pre><code class="hljs bash"><span class="hljs-comment"># Shows "foo" if the exit code is 0 and "bar" if the exit code is non-zero.</span>
%(?.foo.bar)
</code></pre><p>The following expression shows the Euro sign in green if the exit code is 0 and in red if the exit code is non-zero.</p><pre><code class="hljs bash">%(?.%{<span class="hljs-variable">$fg</span>[green]%}.%{<span class="hljs-variable">$fg</span>[red]%})€%{<span class="hljs-variable">$reset_color</span>%}
</code></pre><h3>Git info</h3><p><code>git_prompt_info()</code> function outputs git info such as the branch name and the state of the working tree (clean or dirty). We can customize its output by <code>ZSH_THEME_GIT_PROMPT_*</code> variables.</p><p>I wrote something like this:</p><pre><code class="hljs bash">ZSH_THEME_GIT_PROMPT_PREFIX=<span class="hljs-string">"%{<span class="hljs-variable">$fg</span>[white]%}("</span>
ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="hljs-string">"%{<span class="hljs-variable">$fg</span>[white]%})%{<span class="hljs-variable">$reset_color</span>%}"</span>
ZSH_THEME_GIT_PROMPT_DIRTY=<span class="hljs-string">"*"</span>
ZSH_THEME_GIT_PROMPT_CLEAN=<span class="hljs-string">""</span>

PROMPT=<span class="hljs-string">"... <span class="hljs-variable">$(git_prompt_info)</span> ..."</span>
</code></pre><p>I thought it was done and went back to work. But when I switched the git branch, the prompt stayed the same. Why? I googled again. There was <a href="https://github.com/robbyrussell/oh-my-zsh/issues/4826">an issue</a> for the same problem. The <code>PROMPT</code> needs to be created with single quotes instead of double quotes so that dynamic parts are not evaluated when it's defined!</p><pre><code class="hljs bash">PROMPT=<span class="hljs-string">'... $(git_prompt_info) ...'</span>
</code></pre><h2>Conclusion</h2><p>I have migrated my terminal from bash to zsh. My initial motivation was passive (Catalina deprecated bash), but it's always fun to try something new (to me). I'm looking forward to trying cool zsh plugins and tricks!</p></div></div></div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2019/10/06/interpreter-and-compiler-in-rust/">Writing an interpreter and a compiler in Rust</a></h1><div class="meta"><span class="date">Oct 6, 2019</span> - Rust</div></div><div class="content"><div><p>In the spring of this year, I read <a href="https://interpreterbook.com/">Writing an Interpreter in Go</a> and <a href="https://compilerbook.com/">Writing a Compiler in Go</a> by <a href="https://thorstenball.com/">Thorsten Ball</a>, and implemented <a href="https://github.com/shuhei/cymbal">an interpreter and a compiler</a> from the books in Rust. (I started writing this post in April but left unfinished for six months. Now I'm finishing it.)</p><p>The first book <a href="https://interpreterbook.com/">Writing an Interpreter in Go</a> is about writing a parser and an interpreter for a programming language called Monkey. Monkey's feature set is limited, but it has some interesting features that modern programming languages have—such as function as a first-class citizen and closures.</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> fibonacci = fn(x) {
    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {
        <span class="hljs-number">0</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">1</span>) {
            <span class="hljs-number">1</span>
        } <span class="hljs-keyword">else</span> {
            fibonacci(x - <span class="hljs-number">1</span>) + fibonacci(x - <span class="hljs-number">2</span>)
        }
    }
};
fibonacci(<span class="hljs-number">15</span>);
</code></pre><p>The second book <a href="https://compilerbook.com/">Writing a Compiler in Go</a> taught me to write a simple compiler and a simple virtual machine. The compiler compiles Monkey scripts into instructions (and constants), and the virtual machine executes the instructions. For example, an expression <code>1 + 2</code> is compiled into:</p><pre><code class="hljs rs"><span class="hljs-comment">// Constants</span>
<span class="hljs-built_in">vec!</span>[
    Object::Integer(<span class="hljs-number">1</span>),
    Object::Integer(<span class="hljs-number">2</span>),
]

<span class="hljs-comment">// Instructions</span>
<span class="hljs-built_in">vec!</span>[
    make_u16(OpCode::Constant, <span class="hljs-number">0</span>),
    make_u16(OpCode::Constant, <span class="hljs-number">1</span>),
    make(OpCode::Add),
    make(OpCode::Pop),
]
</code></pre><h2>How I started</h2><p>I had bought <em>Writing an Interpreter in Go</em> more in 2017, but it had been sleeping in my bookshelf (<a href="https://en.wikipedia.org/wiki/Tsundoku">Tsundoku</a>). Recently, I wanted to relearn a little Go for work. I took the book from my bookshelf and started following the book—typing the code in Go. I did two chapters, and new Go syntaxes stopped appearing. I achieved my initial purpose—relearning Go—earlier than I thought because the book used a limited set of Go's language features. Then Rust came to my mind.</p><p>Before starting this project, I had written two simple command-line tools with Rust (<a href="https://github.com/shuhei/colortty">colortty</a> and <a href="https://github.com/shuhei/ynan26">ynan26</a>), but they were too small to learn different aspects of Rust. I wanted to learn more by implementing something not trivial.</p><h2>Good things about Rust</h2><p>First, I rewrote what I had written in Go with Rust and continued the rest of the book. The implementation in Rust was less redundant than the one in Go. Also, it was more type-safe thanks to <code>enum</code>s and <code>Result</code>. Especially <code>enum</code>s were perfect for AST (Abstract Syntax Tree) and evaluated objects.</p><pre><code class="hljs rs"><span class="hljs-comment">// An example of AST</span>
<span class="hljs-meta">#[derive(Debug, PartialEq, Clone, Hash, Eq)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Expression</span></span> {
    Identifier(<span class="hljs-built_in">String</span>),
    IntegerLiteral(<span class="hljs-built_in">i64</span>),
    StringLiteral(<span class="hljs-built_in">String</span>),
    Boolean(<span class="hljs-built_in">bool</span>),
    Array(<span class="hljs-built_in">Vec</span>&lt;Expression&gt;),
    Hash(HashLiteral),
    Index(<span class="hljs-built_in">Box</span>&lt;Expression&gt;, <span class="hljs-built_in">Box</span>&lt;Expression&gt;),
    Prefix(Prefix, <span class="hljs-built_in">Box</span>&lt;Expression&gt;),
    Infix(Infix, <span class="hljs-built_in">Box</span>&lt;Expression&gt;, <span class="hljs-built_in">Box</span>&lt;Expression&gt;),
    If(<span class="hljs-built_in">Box</span>&lt;Expression&gt;, BlockStatement, <span class="hljs-built_in">Option</span>&lt;BlockStatement&gt;),
    FunctionLiteral(<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt;, BlockStatement),
    Call(<span class="hljs-built_in">Box</span>&lt;Expression&gt;, <span class="hljs-built_in">Vec</span>&lt;Expression&gt;),
}
</code></pre><p>However, harder parts came later when the compiler and the virtual machine grew complex.</p><h2>Nested symbol tables were a linked list</h2><p>To implement nested scopes, the Compiler Book uses self-recursive <code>struct</code>s for nested symbol tables. I was struggling with their ownership. I tried <code>Rc</code> and <code>RefCell</code>, but still was not able to get through them.</p><p>Then, I went to Rust Hack and Learn—a local meetup at Mozilla Berlin office—and asked how to get over ownership rules. One person (sorry, I didn't ask his name!) recommended me a book <a href="https://rust-unofficial.github.io/too-many-lists/">Learn Rust With Entirely Too Many Linked Lists </a>.</p><p>The book introduces several versions of linked list implementations in Rust even though its precaution is not to implement linked lists in Rust. It had some techniques that I had recently learned, and much more. After a while, I realized that I had been trying to implement a linked list. Then I changed the self-recursive <code>struct</code> to a <code>Vec</code>, and it solved most of my headaches. So, the book's precaution was right. Don't implement a liked list.</p><pre><code class="hljs rs"><span class="hljs-comment">// Before</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SymbolTable</span></span> {
  store: HashMap&lt;<span class="hljs-built_in">String</span>, Symbol&gt;,

  <span class="hljs-comment">// This is a linked list!</span>
  outer: <span class="hljs-built_in">Option</span>&lt;SymbolTable&gt;;
}

<span class="hljs-comment">// After</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SymbolLayer</span></span> {
  store: HashMap&lt;<span class="hljs-built_in">String</span>, Symbol&gt;,
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SymbolTable</span></span> {
  current: SymbolLayer;
  outers: <span class="hljs-built_in">Vec</span>&lt;SymbolStore&gt;;
}
</code></pre><h2>I learned basics of how programs work at low-level</h2><p>Even before starting the project, I had some vague ideas about parser, interpreter and compiler thanks to my previous projects. But I hadn't had concrete ideas about compilers, especially about how to translate high-level code like function calls and closures into low-level instructions. After the project, now I can confidently say what is on the stack and what is on the heap.</p><p>Also, the knowledge about stack was useful to understand some of the concepts of Rust itself. Rust's compiler to know the sizes of types because it needs to generate machine code that allocates values of the types on the stack.</p><h2>Conclusion</h2><p>It was a fun project. I learned something, but there is much more to learn in Rust. Also, now I can admire modern interpreters and compilers like V8 more than before.</p><p><a href="https://interpreterbook.com/">Writing an Interpreter in Go</a> and <a href="https://compilerbook.com/">Writing a Compiler in Go</a> are great. I liked their hands-on approach with many unit tests.</p></div></div></div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2019/04/30/dns-polling/">DNS polling for reliability</a></h1><div class="meta"><span class="date">Apr 30, 2019</span> - Node.js</div></div><div class="content"><div><p>In December 2018, I wrote a package to poll and cache DNS records, <a href="https://github.com/shuhei/pollen">pollen</a>, as a mitigation for incidents at work.</p><p>My team at work migrated our Node.js servers from AWS EC2 C4 instances to C5 instances. Then mysterious timeout errors on outbound HTTP(S) calls started happening. They happened only in an availability zone at a time. We tried different things to investigate the issue, like profiling and <code>tcpdump</code>, but couldn't find the cause. Eventually, AWS Support suggested that the incidents were correlated to DNS timeouts in their metrics. According to them, C5 instances don't retry DNS lookups while C4 instances do.</p><h2>Node.js is vulnerable to DNS failures</h2><p>In the microservice world, we work hard to make remote procedure calls (with HTTPS) reliable. We use timeout, retry, fallback, etc. to make it as reliable as possible. However, we hadn't paid enough attention to DNS lookup, which we use for service discovery. It can easily be a single point of failure because we can't call servers without knowing their IP addresses.</p><p>Node.js is especially vulnerable to DNS lookup failures because:</p><ul><li>Node.js standard library doesn't have DNS cache by default while other languages/runtimes like Java and Go have it by default.</li><li>Node.js uses a small thread pool to make DNS lookups. When there are slow DNS queries or packet loss, subsequent DNS lookups need to wait for them to finish or timeout.<ul><li>Before <a href="https://github.com/nodejs/node/pull/22997">Node 10.12.0</a>, it was even worse because slow DNS queries affected other tasks in the thread pool like file IO and gzip encoding/decoding.</li></ul></li></ul><h2>Caching at OS-level</h2><p>We can make DNS lookups fast and reliable by caching it. <a href="https://github.com/nodejs/node/issues/5893">An issue on the nodejs/node repo</a> recommends to have caching at OS-level. We can run a daemon like dnsmasq, unbound, CoreDNS, etc.</p><p>However, it's not always easy depending on the platform that you are using. My team was using <a href="https://stups.io/">a platform where we just deploy your application Docker container</a>, and it was hard to set up another daemon on the OS. The majority of the users of the platform were application runtimes such as Java and Go, which have basic DNS caching by default and rarely have the same issues with Node.js applications. It was hard to convince the platform team to introduce per-node DNS caching to the platform only for Node.js applications without a concrete evidence while they were focusing on a new Kubernetes-based platform. (They eventually added per-node DNS caching to the new platform later, but the application in question won't move to it because of reasons...)</p><p>Because the incidents didn't happen on C4 instances and we had other priorities to work on, we just rolled back and kept using C4 instances for a while. However, I wanted to finish the issue before celebrating 2019. So, I decided to implement DNS caching on the application layer with Node.js.</p><h2>DNS caching and prefetching with Node.js</h2><p>There were already some DNS caching packages:</p><ul><li><a href="https://github.com/yahoo/dnscache">yahoo/dnscache</a></li><li><a href="https://github.com/eduardbcom/lookup-dns-cache">eduardbcom/lookup-dns-cache</a></li></ul><p>The packages looked great, but there was an edge case that they didn't cover. Both of the packages throw away caches after some time (<code>dnscache</code> uses <code>ttl</code> option and <code>lookup-dns-cache</code> uses the TTL that DNS servers return) and make DNS lookups again. This poses a risk where HTTP requests fail if DNS servers are down at the time.</p><p>To avoid making DNS lookups on demand, we can prefetch DNS records and always provide cached DNS records. This means that we may get outdated IP addresses. However, DNS records didn't change often for my case. I thought it would be better to use expired DNS records than just giving up. In the worst case, we would get an SSL certificate error if the expired IP addresses point to wrong servers as long as we use HTTPS.</p><h2>HTTP Keep-Alive (persistent connection)</h2><p>There was another issue that I wanted to solve with this package: keeping HTTP Keep-Alive connections as long as possible.</p><p>We have been using HTTP Keep-Alive for good performance. However, we couldn't keep the Keep-Alive connections forever because our backend servers may change their IP addresses (DNS-based traffic switch in our case). To avoid keeping stale connections, we were re-creating TCP/TLS connections for each minute, by rotating HTTP agents and later using the <code>activeSocketTTL</code> option of <code>keepaliveagent</code>. However, this is not optimal because IP addresses don't change most of the time.</p><p>The DNS caching and prefetching tell us when IP addresses change. So we can keep using existing connections as long as IP addresses stay same and re-connect only when IP addresses change. In this way, we can avoid unnecessary TCP/TLS handshakes.</p><h2>Result</h2><p>I wrote <a href="https://github.com/shuhei/pollen">pollen</a>, tested it with C4 instances and migrated our servers to C5 again. No issues happened after five months. So, it seems that DNS failure was the cause and the package can mitigate it.</p><p>I had expected performance improvement because of fewer TCP/TLS handshakes, but I didn't find much difference in latency.</p><h2>How to use it</h2><pre><code class="hljs sh">npm i -S @shuhei/pollen
<span class="hljs-comment"># or</span>
yarn add @shuhei/pollen
</code></pre><pre><code class="hljs js"><span class="hljs-keyword">const</span> https = <span class="hljs-built_in">require</span>(<span class="hljs-string">"https"</span>);
<span class="hljs-keyword">const</span> { DnsPolling, HttpsAgent } = <span class="hljs-built_in">require</span>(<span class="hljs-string">"@shuhei/pollen"</span>);

<span class="hljs-keyword">const</span> dnsPolling = <span class="hljs-keyword">new</span> DnsPolling({
  <span class="hljs-attr">interval</span>: <span class="hljs-number">30</span> * <span class="hljs-number">1000</span> <span class="hljs-comment">// 30 seconds by default</span>
});
<span class="hljs-comment">// Just a thin wrapper of https://github.com/node-modules/agentkeepalive</span>
<span class="hljs-comment">// It accepts all the options of `agentkeepalive`.</span>
<span class="hljs-keyword">const</span> agent = <span class="hljs-keyword">new</span> HttpsAgent();

<span class="hljs-keyword">const</span> hostname = <span class="hljs-string">"shuheikagawa.com"</span>;
<span class="hljs-keyword">const</span> req = https.request({
  hostname,
  <span class="hljs-attr">path</span>: <span class="hljs-string">"/"</span>,
  <span class="hljs-comment">// Make sure to call `getLookup()` for each request!</span>
  <span class="hljs-attr">lookup</span>: dnsPolling.getLookup(hostname),
  agent
});
</code></pre><h2>Bonus: DNS lookup metrics</h2><p>Because DNS lookup is a critical operation, it is a good idea to monitor its rate, errors and latency. <code>pollen</code> emits events for this purpose.</p><pre><code class="hljs js">dnsPolling.on(<span class="hljs-string">"resolve:success"</span>, ({ hostname, duration, update }) =&gt; {
  <span class="hljs-comment">// Hypothetical functions to update metrics...</span>
  recordDnsLookup();
  recordDnsLatency(duration);

  <span class="hljs-keyword">if</span> (update) {
    logger.info({ hostname, duration }, <span class="hljs-string">"IP addresses updated"</span>);
  }
});
dnsPolling.on(<span class="hljs-string">"resolve:error"</span>, ({ hostname, duration, error }) =&gt; {
  <span class="hljs-comment">// Hypothetical functions to update metrics...</span>
  recordDnsLookup();
  recordDnsLatency(duration);
  recordDnsError();

  logger.warn({ hostname, <span class="hljs-attr">err</span>: error, duration }, <span class="hljs-string">"DNS lookup error"</span>);
});
</code></pre><p>I was surprised by DNS lookups occasionally taking 1.5 seconds. It might be because of retries of <a href="https://c-ares.haxx.se/">c-ares</a>, but I'm not sure yet (<a href="https://c-ares.haxx.se/ares_init_options.html">its default timeout seems to be 5 seconds...</a>).</p><p>Because <code>pollen</code> makes fewer DNS lookups, the events don't happen frequently. I came across an issue of histogram implementation that greatly skewed percentiles of infrequent events, and started using HDR histograms. Check out <a href="/blog/2018/12/29/histogram-for-time-series-metrics-on-node-js/">Histogram for Time-Series Metrics on Node.js</a> for more details.</p><p>Even if you don't use <code>pollen</code>, it is a good idea to monitor DNS lookups.</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> dns = <span class="hljs-built_in">require</span>(<span class="hljs-string">"dns"</span>);

<span class="hljs-keyword">const</span> lookupWithMetrics = <span class="hljs-function">(<span class="hljs-params">hostname, options, callback</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> cb = callback || options;
  <span class="hljs-keyword">const</span> startTime = <span class="hljs-built_in">Date</span>.now();

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLookup</span>(<span class="hljs-params">err, address, family</span>) </span>{
    <span class="hljs-keyword">const</span> duration = <span class="hljs-built_in">Date</span>.now() - startTime;
    cb(err, address, family);

    <span class="hljs-comment">// Hypothetical functions to update metrics...</span>
    recordDnsLookup();
    recordDnsLatency(duration);
    <span class="hljs-keyword">if</span> (err) {
      recordDnsError();
      logger.warn({ hostname, err, duration }, <span class="hljs-string">"DNS lookup error"</span>);
    }
  }

  <span class="hljs-keyword">return</span> dns.lookup(hostname, options, onLookup);
};

<span class="hljs-keyword">const</span> req = https.request({
  <span class="hljs-comment">// ...</span>
  <span class="hljs-attr">lookup</span>: lookupWithMetrics
});
</code></pre><h2>Conclusion</h2><p>Give <a href="https://github.com/shuhei/pollen">pollen</a> a try if you are:</p><ul><li>seeing DNS timeouts on outbound API calls</li><li>using DNS for service discovery</li><li>running your Node.js servers without DNS caching</li></ul><p>Also, don't forget to monitor DNS lookups!</p></div></div></div><ul class="pagination"><li class="pagination__prev-page"><a href="/blog/pages/3/">Newer posts</a></li><li class="pagination__archives"><a href="/blog/archives/">All posts</a></li><li class="pagination__next-page"><a href="/blog/pages/5/">Older posts</a></li></ul></div><footer class="footer">© Shuhei Kagawa</footer></div></body></html>