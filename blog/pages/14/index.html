<!doctype html><html lang="en"><head><meta charset="utf-8"><link rel="preload" href="https://fonts.gstatic.com/s/dmmono/v10/aFTU7PB1QTsUX8KYthqQBK6PYK0.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="https://fonts.gstatic.com/s/librebaskerville/v14/kmKhZrc3Hgbbcjq75U4uslyuy4kn0qNcWxEQDO-Wyrs.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="https://fonts.gstatic.com/s/librebaskerville/v14/kmKnZrc3Hgbbcjq75U4uslyuy4kn0qNZaxMaC82U.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="https://fonts.gstatic.com/s/librefranklin/v13/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkANDPTedX18mE.woff" as="font" crossorigin="anonymous"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><meta name="viewport" content="width=device-width,initial-scale=1"><title>Shuhei Kagawa</title><link rel="icon" sizes="16x16 32x32 48x48" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="Atom feed of Shuhei Kagawa" href="/blog/feed.xml"><style>:root{--bg-color:#f9f9f9;--text-color:#222;--highlight-color:#095ae8;--code-text-color:var(--code-mono-1);--code-bg-color:#fff;--syntax-hue:230;--syntax-saturation:1%;--syntax-brightness:100%;--code-mono-1:hsl(var(--syntax-hue),8%,24%);--code-mono-2:hsl(var(--syntax-hue),6%,44%);--code-mono-3:hsl(var(--syntax-hue),4%,64%);--code-hue-1:#0184bc;--code-hue-2:#1d56d3;--code-hue-3:#a626a4;--code-hue-4:#188816;--code-hue-5:#ce3527;--code-hue-5-2:#ca1243;--code-hue-6:#986801;--code-hue-6-2:#986801;--body-font-family:"Libre Baskerville",serif;--heading-font-family:"Libre Franklin",sans-serif;--code-font-family:"DM Mono",monospace}body{background:#f9f9f9;background:var(--bg-color);color:#222;color:var(--text-color);font-family:Libre Baskerville,serif;font-family:var(--body-font-family);font-size:16px;line-height:1.9;margin:0;padding:0}.container{margin:0 auto;padding:0 20px;width:700px}a{color:#095ae8;color:var(--highlight-color);text-decoration:none;transition:color .5s ease}a:hover{text-decoration:underline}.header{display:flex;padding:1.5em 0 1em}.header__title{flex-grow:1;font-size:1em;font-weight:400;margin:0 10px 0 0}.header__title a{color:#222;color:var(--text-color)}.header__nav{flex-grow:0}.menu{list-style-position:outside;list-style-type:none;margin:0;padding:0;text-align:right}.menu__item{display:inline-block;padding:0 0 0 .7em}.menu__item a{color:#222;color:var(--text-color)}.footer{padding:3em 0 4em;text-align:center}.title{font-family:Libre Franklin,sans-serif;font-family:var(--heading-font-family);font-size:3em;line-height:1.1;margin:0 0 .2em}.title a{color:#222;color:var(--text-color);text-decoration:none}.post,.post-list{padding:1.7em 0 1.25em}.post:after{content:"* * *";display:block;font-family:Libre Franklin,sans-serif;font-family:var(--heading-font-family);font-size:4.5em;font-weight:700;line-height:1;margin:.9em auto 0;text-align:center}.post .meta{font-size:.75em}.post-list .title{margin-bottom:10px}.post-list-item{display:flex;line-height:1.6em;padding:10px 0}.post-list-item__date{flex-shrink:0;font-size:.8em;width:8em}.post-list-item__title{font-family:Libre Franklin,sans-serif;font-family:var(--heading-font-family);font-size:1.3em;font-weight:700;margin:0}.post-list-item__title a{color:#222;color:var(--text-color);text-decoration:none}.content h2,.content h3,.content h4,.content h5,.content h6{font-family:Libre Franklin,sans-serif;font-family:var(--heading-font-family);margin:1em 0 0}.content h2{font-size:2.2em;line-height:1.1}.content h3{font-size:1.6em;line-height:1.3}.content h4{font-size:1.2em}.content img{height:auto;max-width:100%}.content p{margin:1.15em 0}.img-wrapper{display:block;text-align:center}.comments{margin-bottom:3em}ol,ul{list-style-position:outside;padding-left:1.4em}.table-wrapper{margin:1.15em 0;overflow-x:auto}.table-wrapper table{border-collapse:collapse;margin:0;width:100%}tr{vertical-align:top}th{font-weight:400;text-align:left}tbody{border-bottom:1px solid #333;border-top:1px solid #333;padding:.5em 0}td,th{padding-right:1em}code{background-color:#fff;background-color:var(--code-bg-color);color:#383a42;color:var(--code-text-color);font-family:DM Mono,monospace;font-family:var(--code-font-family);font-size:.9em;padding:0 .3em}.code__filename{background-color:#666;display:inline-block;font-size:.85em;margin-bottom:13px;padding:5px 10px}.hljs{-webkit-overflow-scrolling:touch;background-color:#fff;background-color:var(--code-bg-color);color:#383a42;color:var(--code-text-color);display:block;line-height:1.5em;overflow-x:auto;padding:1em 20px}.hljs-comment,.hljs-quote{color:#696c77;color:var(--code-mono-2);font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a626a4;color:var(--code-hue-3)}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#ce3527;color:var(--code-hue-5)}.hljs-literal{color:#0184bc;color:var(--code-hue-1)}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#188816;color:var(--code-hue-4)}.hljs-built_in,.hljs-class .hljs-title{color:#986801;color:var(--code-hue-6-2)}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986801;color:var(--code-hue-6)}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#1d56d3;color:var(--code-hue-2)}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}blockquote{font-style:italic;margin:1.5em 0;padding:0 0 0 2em}blockquote p:first-child:before{content:open-quote;font-family:serif;font-size:3em;font-weight:700;line-height:.1em;margin-right:.2em;vertical-align:-.4em}blockquote cite{color:#999990}blockquote cite:before{content:"- "}.pagination{display:flex;justify-content:space-between;list-style-position:outside;list-style-type:none;margin-top:20px;padding:0}.pagination__next-page,.pagination__prev-page{width:46%}.pagination__next-page{text-align:right}.footer-nav{text-align:center}@media only screen and (max-width:767px){body{font-size:15px;line-height:1.65}.container{width:auto}.post,.post-list{padding-top:10px}.post-list-item{display:block}.hljs{border-radius:0;margin-left:-20px;margin-right:-20px;padding:1.4em 20px}li .hljs{margin-left:0}.img-wrapper{margin-left:-20px;margin-right:-20px}}@font-face{font-display:swap;font-family:DM Mono;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/dmmono/v10/aFTU7PB1QTsUX8KYthSQBK6PYK3EXw.woff2) format("woff2");unicode-range:u+0100-02af,u+1e??,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:DM Mono;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/dmmono/v10/aFTU7PB1QTsUX8KYthqQBK6PYK0.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-display:swap;font-family:Libre Baskerville;font-style:italic;font-weight:400;src:url(https://fonts.gstatic.com/s/librebaskerville/v14/kmKhZrc3Hgbbcjq75U4uslyuy4kn0qNcWx8QDO-WyrubOA.woff2) format("woff2");unicode-range:u+0100-02af,u+1e??,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:Libre Baskerville;font-style:italic;font-weight:400;src:url(https://fonts.gstatic.com/s/librebaskerville/v14/kmKhZrc3Hgbbcjq75U4uslyuy4kn0qNcWxEQDO-Wyrs.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-display:swap;font-family:Libre Baskerville;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/librebaskerville/v14/kmKnZrc3Hgbbcjq75U4uslyuy4kn0qNXaxMaC82U-ro.woff2) format("woff2");unicode-range:u+0100-02af,u+1e??,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:Libre Baskerville;font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/librebaskerville/v14/kmKnZrc3Hgbbcjq75U4uslyuy4kn0qNZaxMaC82U.woff2) format("woff2");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}@font-face{font-display:swap;font-family:Libre Franklin;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/librefranklin/v13/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkD9DPTedX18mETQw.woff) format("woff");unicode-range:u+0102-0103,u+0110-0111,u+0128-0129,u+0168-0169,u+01a0-01a1,u+01af-01b0,u+1ea0-1ef9,u+20ab}@font-face{font-display:swap;font-family:Libre Franklin;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/librefranklin/v13/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkDtDPTedX18mETQw.woff) format("woff");unicode-range:u+0100-02af,u+1e??,u+2020,u+20a0-20ab,u+20ad-20cf,u+2113,u+2c60-2c7f,u+a720-a7ff}@font-face{font-display:swap;font-family:Libre Franklin;font-style:normal;font-weight:700;src:url(https://fonts.gstatic.com/s/librefranklin/v13/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkANDPTedX18mE.woff) format("woff");unicode-range:u+00??,u+0131,u+0152-0153,u+02bb-02bc,u+02c6,u+02da,u+02dc,u+2000-206f,u+2074,u+20ac,u+2122,u+2191,u+2193,u+2212,u+2215,u+feff,u+fffd}</style><meta name="description" content="A personal website of Shuhei Kagawa. I write mostly on web technologies and life."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@shuheikagawa"><meta property="og:title" content="Shuhei Kagawa"><meta property="og:site_name" content="Shuhei Kagawa"><meta property="og:description" content="A personal website of Shuhei Kagawa. I write mostly on web technologies and life."></head><body><div class="container"><header class="header"><h1 class="header__title"><a href="/">Shuhei Kagawa</a></h1><nav class="header__nav"><ul class="menu"><li class="menu__item"><a href="/about/">About</a></li><li class="menu__item"><a href="/blog/archives/">All posts</a></li></ul></nav></header><div class="main"><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2015/09/13/lets-create-a-babel-plugin/">Let's create a Babel plugin</a></h1><div class="meta"><span class="date">Sep 13, 2015</span> - <a href="/blog/tags/JavaScript">JavaScript</a>, <a href="/blog/tags/Babel">Babel</a></div></div><div class="content"><div><p><em>[EDIT] This article was written for Babal 5.x, which is outdated now. I recommend <a href="https://github.com/thejameskyle/babel-handbook/">thejameskyle/babel-handbook</a> as more up-to-date documentation.</em></p><p><a href="https://babeljs.io/">Babel</a> is the great tool that transpiles ES2015, ES7, JSX and such into ES5 and make them available on the browsers. If you are a person like me, you might use it on a daily basis.</p><p>In addition to to <a href="https://babeljs.io/docs/advanced/transformers/">the built-in transformers</a>, you can add your own transpilation rules by employing third-party plugins. For example, I have been developing <a href="https://github.com/shuhei/babel-plugin-angular2-annotations">a plugin that enables you to write Angular 2 apps with Babel</a> lately. It is easier to develop than you may think. Let me introduce how to create a plugin for Babel 5.x.</p><h2>How Babel works</h2><p>Simply put, Babel works like the following:</p><ol><li>Babylon, the parser of Babel, parses source code into AST.</li><li>Transformers transforms AST into another AST in sequence.</li><li>Generators generates JavaScript code from the final AST.</li></ol><p>In the step 1, AST is for <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a>, which represents the structure of source code as a tree. Babel's AST is based on a specfication called ESTree and has some extensions for non-standard nodes like ES7+, JSX and flowtype. You can check the ESTree spec at the following links:</p><ul><li><a href="https://github.com/estree/estree/blob/master/spec.md">Core</a></li><li><a href="https://github.com/estree/estree/blob/master/es6.md">ES6</a></li></ul><p>In the step 2, transformers consists of <a href="https://babeljs.io/docs/advanced/transformers/">the built-in transformers</a>, like <a href="es6.classes">es6.classes</a>, and third-party plugin transformers. As of Babel 6.0, the built-in transpilers will also be extracted as external plugin modules. So there will be no border between the build-in and third-party plugins.</p><p>So, what you have to do is write a transformer that transforms AST into another AST. You don't need to parse JS or generate JS from AST by yourself. It will be greatly effective compared to introducing another tool that parses JS by its own. Also, Babel's powerful API will make it easier than using the raw esprima tools.</p><h2>What you can (not) do</h2><p>You can do almost anything as long as it's in the syntax that Babylon supports, ES2015, ES7+, JSX, flowtype and etc. You can't introduce new syntax because Babel currently doesn't support parser extension by plugins. (You can actually accomplish it by monkey-patching Babylon though.)</p><h2>Create a project</h2><p>Create a directory in the format of <code>babel-plugin-*</code>. The <code>*</code> part turns to be your plugin name. In the directory, you can create a Babel plugin project with <code>babel-plugin init</code>, which is installed by <code>npm install -g babel</code>.</p><pre><code class="hljs sh"><span class="hljs-comment"># Prepare a project directory.</span>
<span class="hljs-built_in">mkdir</span> babel-plugin-foo-bar
<span class="hljs-built_in">cd</span> babel-plugin-foo-bar
<span class="hljs-comment"># Generate necessary files.</span>
npm install -g babel
babel-plugin init
<span class="hljs-comment"># Install dependencies.</span>
npm install
</code></pre><p>The following structure should have been generated:</p><pre><code class="hljs">.
├── .gitignore
├── .npmigonore
├── LICENSE
├── README.md
├── node_modules
├── package.json
└── src
 &nbsp;&nbsp; └── index.js
</code></pre><p>You will find some npm-run-scripts in the <code>package.json</code>:</p><ul><li><code>npm run build</code> transpiles files under <code>src</code> directory with Babel and output the result into <code>lib</code> directory.</li><li><code>npm run push</code> releases a newer version of the plugin. It takes care of git commit, tag and npm package.</li><li><code>npm test</code> runs <code>babel-plugin test</code> but fails because the command doesn't exist. <a href="https://github.com/babel/babel/issues/1950">It seems like it will work in the future.</a> So, prepare your favorite test runner like <code>mocha</code> for now.</li></ul><p>With this setup, you can write your plugin itself with Babel's features. <code>src</code> should be ignored in npm and <code>lib</code> in git.</p><h2>Transformer</h2><p><code>src/index.js</code>, the meat of the plugin, looks like this:</p><pre><code class="hljs js"><span class="hljs-comment">/* eslint no-unused-vars:0 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">{ Plugin, types: t }</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin</span>(<span class="hljs-string">"foo"</span>, {
    <span class="hljs-attr">visitor</span>: {
      <span class="hljs-comment">// your visitor methods go here</span>
    }
  });
}
</code></pre><p>It exports a factory function that creates a <code>Plugin</code> instance. The <code>Plugin</code> constructor gets the plugin's name and a configuration object.</p><p>The <code>visitor</code> property holds methods named as AST node types. A Babel transformer traverses AST from the top to the bottom. Each method is called when the trasnformer visits the matched nodes. For instance, you can manipulate class declarations and function declarations as the following:</p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">{ Plugin, types: t }</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin</span>(<span class="hljs-string">"foo"</span>, {
    <span class="hljs-attr">visitor</span>: {
      <span class="hljs-title class_">ClassDeclaration</span>(node, parent) {
        <span class="hljs-comment">// Do something on a class declaration node.</span>
      },
      <span class="hljs-title class_">FunctionDeclaration</span>(node, parent) {
        <span class="hljs-comment">// Do something on a function declaration node.</span>
      }
    }
  });
}
</code></pre><p>You can also use <code>alias</code> instead of plain node types to match multiple node types. For example, <code>Function</code> matches against <code>FunctionDeclaration</code> and <code>FunctionExpression</code>.</p><p><code>types</code> is another important thing. It contains a bunch of utility functions for AST manipulation.</p><ul><li>AST node generation functions such as <code>identifier()</code>, <code>memberExpression()</code> and <code>assignmentExpression</code>. Their names are lowerCamelCased versions of the corresponding node types. You can check their arguments at <a href="https://github.com/babel/babel/tree/master/packages/babel/src/types/definitions">definitions</a>' <code>builder</code> properties.</li><li>AST node check functions such as <code>isIdentifier()</code> and <code>isDecorator()</code>. You can shallowly check node properties with the second argument.</li></ul><p>The functions are <a href="https://github.com/babel/babel/blob/v5.8.24/packages/babel/src/types/index.js">generated</a> from <a href="https://github.com/babel/babel/tree/master/packages/babel/src/types/definitions">definitions</a>。The definitions will serve as a reference.</p><p>The best examples of AST transformation using <code>types</code> functions are undoubtedly <a href="https://github.com/babel/babel/tree/v5.8.24/packages/babel/src/transformation/transformers">the source code of the built-in transformers</a>. Pick the closest one to what you want from <a href="https://babeljs.io/docs/advanced/transformers/">the list</a> and check out the source code. <a href="https://babeljs.io/docs/advanced/plugins/">The official documentation</a> will also help.</p><h2>Case study: Assign class constructor's arguments as instance properties</h2><p>As a case study, I built a plugin called <a href="https://github.com/shuhei/babel-plugin-auto-assign">babel-plugin-auto-assign</a> that "assigns class constructor's arguments as instance properties", which resembles TypeScript's parameter properties in its action. It is intended to be used with class-based dependency injection like Angular's.</p><p>To avoid unawarely messing up constructors, let's apply the transformation only to classes with a decrator called <code>@autoAssign</code>. <code>@autoAssign</code> is a so-called <a href="https://github.com/jonathandturner/brainstorming/blob/master/README.md#c6-ambient-decorators">ambient decorator</a> because it should not appear in the output.</p><p>Before:</p><pre><code class="hljs js">@autoAssign
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">foo, bar, baz</span>) {}
}
</code></pre><p>After:</p><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">foo, bar, baz</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> = foo;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = bar;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">baz</span> = baz;
  }
}
</code></pre><p>Note that we can leave the ES6 class as is because it's going to be transformed to ES5 by the subsequent built-in transformers. Babel plugin transformers are applied <em>before</em> the built-in transformers by default. If you want to apply a plugin after the built-in transformers, suffix the plugin name with <code>:after</code> like <code>babel --plugins foo:after index.js</code>.</p><h2>AST before/after transformation</h2><p>To transform AST, we need to know how the starting post and the goal look like. You can visualize source code in AST parsed by Babylon with <a href="http://felix-kling.de/esprima_ast_explorer">Felix Kling's JS AST Explorer</a>.</p><ul><li><a href="http://felix-kling.de/esprima_ast_explorer/#/OuFSNzgCl2">Before transformation</a></li><li><a href="http://felix-kling.de/esprima_ast_explorer/#/tZsOQTyns6">After transformation</a></li></ul><p>It also works to examine nodes with <code>console.log()</code>.</p><h2>Code</h2><p>Once you get the ASTs, half of the work is done. Let's write some code to insert AST nodes using <code>types</code> functions.</p><p><a href="https://github.com/shuhei/babel-plugin-auto-assign">The complete project</a> includes unit testing with fixtures.</p><p><code>src/index.js</code></p><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoAssign</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./auto-assign"</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">{ Plugin, types: t }</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Plugin</span>(<span class="hljs-string">"autoAssign"</span>, {
    <span class="hljs-attr">visitor</span>: {
      <span class="hljs-title class_">ClassDeclaration</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">node, parent</span>) {
        <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoAssign</span>(t).<span class="hljs-title function_">run</span>(node);
      }
    }
  });
}
</code></pre><p><code>src/auto-assign.js</code></p><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoAssign</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">types</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">types</span> = types;
  }

  <span class="hljs-title function_">run</span>(<span class="hljs-params">klass</span>) {
    <span class="hljs-comment">// Process only if `@autoAssign` decorator exists.</span>
    <span class="hljs-keyword">const</span> decorators = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">findautoAssignDecorators</span>(klass);
    <span class="hljs-keyword">if</span> (decorators.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// Get constructor and its paremeters.</span>
      <span class="hljs-keyword">const</span> ctor = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">findConstructor</span>(klass);
      <span class="hljs-keyword">const</span> args = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getArguments</span>(ctor);
      <span class="hljs-comment">// Prepend assignment statements to the constructor.</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">prependAssignments</span>(ctor, args);
      <span class="hljs-comment">// Delete `@autoAssign`.</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">deleteDecorators</span>(klass, decorators);
    }
  }

  <span class="hljs-title function_">findautoAssignDecorators</span>(<span class="hljs-params">klass</span>) {
    <span class="hljs-keyword">return</span> (klass.<span class="hljs-property">decorators</span> || []).<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">decorator</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> decorator.<span class="hljs-property">expression</span>.<span class="hljs-property">name</span> === <span class="hljs-string">"autoAssign"</span>;
    });
  }

  <span class="hljs-title function_">deleteDecorators</span>(<span class="hljs-params">klass, decorators</span>) {
    decorators.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">decorator</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> index = klass.<span class="hljs-property">decorators</span>.<span class="hljs-title function_">indexOf</span>(decorator);
      <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) {
        klass.<span class="hljs-property">decorators</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);
      }
    });
  }

  <span class="hljs-title function_">findConstructor</span>(<span class="hljs-params">klass</span>) {
    <span class="hljs-keyword">return</span> klass.<span class="hljs-property">body</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">body</span> =&gt;</span> {
      <span class="hljs-keyword">return</span> body.<span class="hljs-property">kind</span> === <span class="hljs-string">"constructor"</span>;
    })[<span class="hljs-number">0</span>];
  }

  <span class="hljs-title function_">getArguments</span>(<span class="hljs-params">ctor</span>) {
    <span class="hljs-keyword">return</span> ctor.<span class="hljs-property">value</span>.<span class="hljs-property">params</span>;
  }

  <span class="hljs-title function_">prependAssignments</span>(<span class="hljs-params">ctor, args</span>) {
    <span class="hljs-keyword">const</span> body = ctor.<span class="hljs-property">value</span>.<span class="hljs-property">body</span>.<span class="hljs-property">body</span>;
    args
      .<span class="hljs-title function_">slice</span>()
      .<span class="hljs-title function_">reverse</span>()
      .<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> {
        <span class="hljs-keyword">const</span> assignment = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">buildAssignment</span>(arg);
        body.<span class="hljs-title function_">unshift</span>(assignment);
      });
  }

  <span class="hljs-title function_">buildAssignment</span>(<span class="hljs-params">arg</span>) {
    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>.<span class="hljs-property">types</span>.<span class="hljs-title function_">identifier</span>(<span class="hljs-string">"this"</span>);
    <span class="hljs-keyword">const</span> prop = <span class="hljs-variable language_">this</span>.<span class="hljs-property">types</span>.<span class="hljs-title function_">memberExpression</span>(self, arg);
    <span class="hljs-keyword">const</span> assignment = <span class="hljs-variable language_">this</span>.<span class="hljs-property">types</span>.<span class="hljs-title function_">assignmentExpression</span>(<span class="hljs-string">"="</span>, prop, arg);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">types</span>.<span class="hljs-title function_">expressionStatement</span>(assignment);
  }
}
</code></pre><h2>Run!</h2><p>Use <code>--optional es7.decorators</code> option in order to support decorators. You can specify plugins by file path in addition to plugin name, which is convenient for development.</p><pre><code class="hljs">npm run build
echo '@autoAssign class Hello { constructor(foo, bar, baz) {} }' | babel --optional es7.decorators --plugins ./lib/index.js
</code></pre><p>Here comes the result!</p><pre><code class="hljs js"><span class="hljs-meta">"use strict"</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-params">instance, Constructor</span>) {
  <span class="hljs-keyword">if</span> (!(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Constructor</span>)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">"Cannot call a class as a function"</span>);
  }
}

<span class="hljs-keyword">var</span> <span class="hljs-title class_">Hello</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params">foo, bar, baz</span>) {
    <span class="hljs-title function_">_classCallCheck</span>(<span class="hljs-variable language_">this</span>, _Hello);

    <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> = foo;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">bar</span> = bar;
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">baz</span> = baz;
  }

  <span class="hljs-keyword">var</span> _Hello = <span class="hljs-title class_">Hello</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Hello</span>;
})();
</code></pre><h2>Publish</h2><p>After you write README and commit it, you can publish your plugin to the world by <code>npm run push</code>.</p><p>Let's create awesome babel plugins!</p><h2>References</h2><h3>Documentation</h3><ul><li><a href="https://babeljs.io/docs/advanced/plugins/">Plugins - Babel</a></li><li><a href="https://github.com/estree/estree">ESTree</a></li><li><a href="https://github.com/babel/babel/tree/v5.8.24/packages/babel/src/transformation/transformers">Built-in transformers</a></li></ul><h3>Projects</h3><ul><li><a href="https://github.com/shuhei/babel-plugin-auto-assign">shuhei/babel-plugin-auto-assign</a> The case study project in this article.</li><li><a href="https://github.com/shuhei/babel-plugin-angular2-annotations">shuhei/babel-plugin-angular2-annotations</a> A plugin for building Angular 2 app with Babel. It supports TypeScript-like method parameter decorators by monkey-patching Babylon.</li></ul></div></div></div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2015/03/02/date-timezone/">Assign Time/time string in UTC to Active<wbr>Record date attribute</a></h1><div class="meta"><span class="date">Mar 2, 2015</span> - <a href="/blog/tags/Ruby">Ruby</a>, <a href="/blog/tags/Rails">Rails</a></div></div><div class="content"><div><p><em>TL;DR: <code>gem 'date_timezone'</code> in <code>Gemfile</code> and <code>include DateTimezone</code> in ActiveRecord models if you are on the east side of the prime meridian.</em></p><p>ActiveRecord is great. It automatically converts data <a href="https://github.com/rails/rails/tree/v4.2.0/activerecord/lib/active_record/type">according to the type of database column</a>. That's why we can throw request params, whose values are often strings, into mass assignment methods like <code>create</code> and <code>update</code> without manual conversion. The conversion works perfectly in most of the cases except for <code>date</code> attribute.</p><p>To <code>date</code> attribute, we can assign <code>Date</code> and date string like <code>'2015-03-02'</code> without any problem. However, <code>Time</code> and time string with different time zone, usualy UTC, don't work well here. Their own time zones are not taken into account when converted to <code>Date</code>.</p><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &lt; <span class="hljs-title class_ inherited__">Rails::Application</span>
  config.time_zone = <span class="hljs-string">'Tokyo'</span>
<span class="hljs-keyword">end</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &lt; <span class="hljs-title class_ inherited__">ActiveRecord::Base</span>
  <span class="hljs-comment"># birth_date :date</span>
<span class="hljs-keyword">end</span>

expect(<span class="hljs-title class_">Person</span>.new(<span class="hljs-symbol">birth_date:</span> <span class="hljs-string">'2015-03-02'</span>).birth_date).to eq(<span class="hljs-title class_">Date</span>.new(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>))
expect(<span class="hljs-title class_">Person</span>.new(<span class="hljs-symbol">birth_date:</span> <span class="hljs-title class_">Date</span>.new(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)).birth_date).to eq(<span class="hljs-title class_">Date</span>.new(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>))
expect(<span class="hljs-title class_">Person</span>.new(<span class="hljs-symbol">birth_date:</span> <span class="hljs-title class_">Time</span>.zone.local(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)).birth_date).to eq(<span class="hljs-title class_">Date</span>.new(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>))

<span class="hljs-comment"># But...</span>
expect(<span class="hljs-title class_">Person</span>.new(<span class="hljs-symbol">birth_date:</span> <span class="hljs-title class_">Time</span>.utc(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>)).birth_date).to eq(<span class="hljs-title class_">Date</span>.new(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>))
expect(<span class="hljs-title class_">Person</span>.new(<span class="hljs-symbol">birth_date:</span> <span class="hljs-string">'2015-03-01T15:00:00.000Z'</span>).birth_date).to eq(<span class="hljs-title class_">Date</span>.new(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>))
</code></pre><p>There may be several cases that we have to assign <code>Time</code> or time string in different time zone to <code>date</code> attribute. My own case was a Single Page Application built with AngularJS that sends JavaScript's <code>Date</code> object to Rails API. JavaScript's <code>JSON.parse()</code> serializes <code>Date</code> into a string of ISO 8601 format in UTC time zone. This is problematic to the people on the east side of the prime meridian because they get different date when they express their beginning of date in UTC.</p><pre><code class="hljs javascript"><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({ <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span> - <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) });
<span class="hljs-comment">// '{"date":"2015-03-01T15:00:00.000Z"}'</span>
</code></pre><p>I could have controlled front-end code to always send date string like <code>'2015-03-02'</code> or converted the ISO 8601 string with <code>Time.zone.parse</code> in Rails controllers. But those approaches seemed error prone. I wanted to take care of it at the bottom, ActiveRecord model. I created a concern to override <code>date</code>-column mutators like the following. It converts <code>Time</code> and time string to <code>TimeWithZone</code> with the application's time zone.</p><pre><code class="hljs">def birth_date=(value)
  self[:birth_date] = case value
                      when String then Time.zone.parse(value)
                      when Time then value.in_time_zone
                      else value
                      end
end
</code></pre><p>The concern was extracted as a gem, <a href="https://github.com/shuhei/date_timezone">date_timezone</a>.</p><pre><code class="hljs Gemfile">gem 'date_timezone'
</code></pre><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &lt; <span class="hljs-title class_ inherited__">ActiveRecord::Base</span>
  <span class="hljs-keyword">include</span> <span class="hljs-title class_">DateTimezone</span>

  <span class="hljs-comment"># birth_date :date</span>
<span class="hljs-keyword">end</span>
</code></pre><p>If you are creating Rails application on the east side of the prime meridian and in trouble with the same issue as mine, please try it and share what you think.</p></div></div></div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2015/02/15/playing-with-vanilla-webgl-api/">Playing with vanilla WebGL API</a></h1><div class="meta"><span class="date">Feb 15, 2015</span> - <a href="/blog/tags/JavaScript">JavaScript</a>, <a href="/blog/tags/WebGL">WebGL</a></div></div><div class="content"><div><p>Started writing in English on a whim.</p><p>I've been learning vanilla WebGL with <a href="https://github.com/stackgl/webgl-workshop">webgl-workshop</a> since the last weekend. It took some time for me to understand concepts like array buffer and element buffer but it was fun to learn the basics that we stand on.</p><p>The team behind <a href="https://github.com/stackgl/webgl-workshop">webgl-workshop</a> creates a set of utility modules called <a href="http://stack.gl/"><code>stackgl</code></a>. It embraces the UNIX philosophy, "Write programs that do one thing and do it well." Even though the workshop doesn't use <code>stackgl</code> libraries, I liked the way the exercises were organized as small modules.</p><p>Before moving to another workshop module, <a href="https://github.com/stackgl/shader-school">shader-school</a>, I ported my old openFrameworks experiment with vanilla WebGL and Audio User Media in order to check if I could use what I learned so far.</p><p><a href="/blurred-cube"><span class="img-wrapper"><picture><source type="image/avif" srcset="/cached/MfQnUK_WGh-500.avif 500w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><source type="image/webp" srcset="/cached/MfQnUK_WGh-500.webp 500w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><img alt="Blurred Cube" loading="lazy" decoding="async" style="background-size: cover; background-image: url(&quot;data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 9 7'%3E %3Cfilter id='b' color-interpolation-filters='sRGB'%3E %3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E %3CfeComponentTransfer%3E %3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E %3C/feComponentTransfer%3E %3C/filter%3E %3Cimage filter='url(%23b)' x='0' y='0' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAHCAIAAABV+fA3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAi0lEQVQImT3O2wqFIBQE0P7//3wKIUnRrVQ7zQtEzqELZx5nwTADnuScvffjOBpjeu9vOQAgommaAKSUmDmE8PJtzrlt20opSql5nrXWKaXbruta1/U8TymlEIKIYoy11ttKKUKIGGPO+TgOAEopa+23ue/7sixE5JwLIRhjmPkzAL13Zvbet9b+P39bebLYL6ge6gAAAABJRU5ErkJggg=='%3E %3C/image%3E %3C/svg%3E&quot;)" src="/cached/MfQnUK_WGh-500.png" width="500" height="432"></picture></span></a></p><p><a href="/blurred-cube">Blurred Cube</a></p><p>The hardest part was randomly moving the cube's edges. Because I couldn't randomly move vertices on the array buffer, I had to rewrite buffer data frame by frame. It might be inefficient, but it works well on my laptop at least.</p><h2>Steps for drawing with WebGL</h2><p>The exercises on <a href="https://github.com/stackgl/webgl-workshop">webgl-workshop</a> split steps into two phases, <code>init</code> and <code>draw</code>, like <a href="https://processing.org/">Processing</a>. Here I leave a note on general steps in them for later use.</p><h3>Init</h3><ol><li>Compile shaders and link them into a program. If you have attributes in vertex shader, don't forget to set attribute location before linking. If you have uniforms, get their locations after linking for later use.</li><li>Create buffers and assign data to them.</li><li>Create element buffers and assign data to them if necessary.</li><li>Create textures and assign data to them if necessary. You can use textures in fragment shader via texture unit number as uniform.</li></ol><h3>Draw</h3><ol><li>Use program, assign data to uniforms. If they don't change frame by frame, you can do this in the setup phase.</li><li>Bind buffer. If you have only one buffer, you may have done this in the setup phase.</li><li>Draw arrays or elements.</li></ol></div></div></div><ul class="pagination"><li class="pagination__prev-page"><a href="/blog/pages/13/">Newer posts</a></li><li class="pagination__next-page"><a href="/blog/pages/15/">Older posts</a></li></ul><nav class="footer-nav"><a href="/blog/archives/">All posts</a></nav></div><footer class="footer">© Shuhei Kagawa</footer></div></body></html>