{"site":{"title":"Shuhei Kagawa","author":"Shuhei Kagawa","perPage":3,"newPageExtension":"markdown","blogDir":"blog","sourceDir":"source","layoutDir":"_layouts","postDir":"_posts","cssFiles":["node_modules/highlight.js/styles/monokai-sublime.css","source/_css/style.css"]},"posts":[{"layout":"post","title":"iPhone で OpenFrameworks","published":true,"date":"2009-08-02 20:41","comments":true,"tags":null,"categories":["C/C++","iPhone 開発","OpenFrameworks"],"url":"/blog/2009/08/02/openframeworks-on-iphon/","content":"<p>二次元で Strange Attractor 的なものをつくってみました。パーティクルの点描ではなく軌跡を描いています。</p>\n<p><a href=\"http://www.flickr.com/photos/branchiopoda/3780153165/\" title=\"Attractor2D by shuhei kagawa, on Flickr\"><img src=\"http://farm4.static.flickr.com/3479/3780153165_68805a6ef5.jpg\" width=\"269\" height=\"500\" alt=\"Attractor2D\" /></a></p>\n<p>Processing と全く同じような感じで書けるので、よけいなことに労力を費やさずにすみます。今後 iPhone で OpenFrameworks を使って行くならば、UIKit との組み合わせ方と、審査が通るかどうかを調べなければいけませんね。</p>"},{"layout":"post","title":"OpenGL のブレンディング方法について","published":true,"date":"2009-08-02 19:03","comments":true,"tags":null,"categories":["C/C++","OpenFrameworks"],"url":"/blog/2009/08/02/blending-of-openg/","content":"<p>OpenFrameworks が iPhone 上で動くというので、触ってみています。ついこの前、Objective-C やりますと書きましたが、最近 C++ がマイブームなので・・・。</p>\n<p>そこで調べてみた OpenGL のブレンディングについてメモ。一言で言うと、ブレンディングとは画像に画像を合成することです。Photoshopなどでは、レイヤーとレイヤーの画像の合成の方法をブレンドモードと言っていますね。OpenGL では自分で書く訳ですから、ブレンディングの方法をさらに柔軟に指定できます。</p>\n<h3>まずは有効に</h3>\n<p>ブレンディングを有効にするには以下の関数を呼ばなければなりません。</p>\n<pre class=\"prettyprint\">glEnable(GL_BLEND);</pre>\n<h3>設定関数</h3>\n<p>ブレンドする二つの画像を source と destination とします。OpenGLでは、これから描くのがsource、destinationはフレームバッファ上の画像だそうです。</p>\n<h4>glBlendFunc</h4>\n<p><code>glBlendFunc</code> では、それぞれの画像の <span class=\"caps\">RGBA</span> にかける係数を設定します。下記は一例です。</p>\n<ul>\n\t<li><code>GL_ONE</code>　<span class=\"caps\">RGBA</span> 全てを0にする</li>\n\t<li><code>GL_ZERO</code>　<span class=\"caps\">RGBA</span> 全てそのまま</li>\n\t<li><code>GL_SRC_ALPHA</code>　<span class=\"caps\">RGBA</span> 全てに source のAをかける</li>\n</ul>\n<h4>glBlendEquation</h4>\n<p><code>glBlendEquation</code> では、画像同士の<span class=\"caps\">RGBA</span>を合成する方法を設定します。</p>\n<ul>\n\t<li><code>GL_FUNC_ADD</code> 足す</li>\n\t<li><code>GL_FUNC_SUBTRACT</code> sourceからdestinationを引く</li>\n\t<li><code>GL_FUNC_REVERSE_SUBTRACT</code> destinationからsourceを引く</li>\n\t<li><code>GL_MAX</code> 大きい方をそのまま使う</li>\n\t<li><code>GL_MIN</code> 小さい方をそのまま使う</li>\n</ul>\n<h4>その他</h4>\n<p>iPhone では <code>glBlendEquation</code> ではなく <code>glBlendEquationOES</code> を使いますが、働きは同じもののようです。また <code>glBlendFunc</code> や <code>glBlendEquation</code> では <span class=\"caps\">RGBA</span> 全てを一緒に設定しますが、 <code>glBlendFuncSeparate</code> や <code>glBlendEquationSeparate</code> を用いると <span class=\"caps\">RGB</span> と Alpha を別々に設定できるようです。</p>\n<h3>実例</h3>\n<h4>Additive blending</h4>\n<p>光の表現に。暗めの色を重ねていくと、ぼんやりと光るようないい感じになります。</p>\n<pre class=\"prettyprint\">glBlendEquationOES(GL_FUNC_ADD);  // デフォルトは GL_FUNC_ADD のようで必要ないかも\nglBlendFunc(GL_ONE, GL_ONE);\n// glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_COLOR); // こっちの方がいい感じになるとか・・・。</pre>\n<h4>フェードアウト</h4>\n<p>もっといい方法があるかもしれませんが、他にやり方が思いつかなかったので。</p>\n<pre class=\"prettyprint\">glBlendEquationOES(GL_FUNC_REVERSE_SUBTRACT_OES);  // 暗くするため、元画像から引く\nglBlendFunc(GL_ONE, GL_ONE);  // そのまま\nofSetColor(10, 10, 10, 0);  // 少しずつ暗くします\nofRect(0, 0, ofGetWidth(), ofGetHeight());  // 画面全体に適用します\n</pre>"},{"layout":"post","title":"const とポインタ","published":true,"date":"2009-08-01 14:45","comments":true,"tags":null,"categories":["C/C++"],"url":"/blog/2009/08/01/const-and-pointe/","content":"<p>下のように <code>const</code> は型名の前後どちらに書いても同じです。</p>\n<pre class=\"prettyprint\">const int a = 1;\nint const b = 2;</pre>\n<p><a href=\"http://www.research.att.com/~bs/bs_faq2.html#constplacement\">Bjarne Stroustrup&#8217;s C++ Style and Technique <span class=\"caps\">FAQ</span></a> では、前者がわかりやすくおすすめとされていますが。</p>\n<p>では、ポインタについてはどうでしょうか？</p>\n<pre class=\"prettyprint\">const int* pa = new int(10);  // \"const な int\" へのポインタ\nint const* pb = new int(11);  // \"const な int \" へのポインタ\nint* const pc = new int(12);  // int への  \"const なポインタ\"</pre>\n<p>一つ目と二つ目は同じです。では、どのような挙動になるのでしょうか？</p>\n<pre class=\"prettyprint\">// *pa = 20;  // エラー！ \"const な int\" の値を変えることはできない\n// *pb = 21;  // エラー！ \"const な int\" の値を変えることはできない\n*pc = 23;\n\ndelete pa;   // delete はできる\ndelete pb;   // delete はできる\ndelete pc;\n\npa = NULL;\npb = NULL;\n// pc = NULL;  // エラー！ポインタ自体が const なため</pre>\n<p>というような感じになります。普通は <code>const int* pa</code> の方を使う機会が多いような気がしますね。</p>"}],"prevPage":"/blog/pages/28/","title":"Page 29 - Shuhei Kagawa","nextPage":"/blog/pages/30/"}