<!doctype html><html lang="en"><head><meta charset="utf-8"><link rel="preload" href="https://fonts.gstatic.com/s/dmmono/v5/aFTU7PB1QTsUX8KYthqQBK6PYK0.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="https://fonts.gstatic.com/s/librebaskerville/v9/kmKhZrc3Hgbbcjq75U4uslyuy4kn0qNcWxEQDO-Wyrs.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="https://fonts.gstatic.com/s/librebaskerville/v9/kmKnZrc3Hgbbcjq75U4uslyuy4kn0qNZaxMaC82U.woff2" as="font" crossorigin="anonymous"><link rel="preload" href="https://fonts.gstatic.com/s/librefranklin/v7/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkANDPTedX18mE.woff" as="font" crossorigin="anonymous"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><meta name="viewport" content="width=device-width,initial-scale=1"><title>Shuhei Kagawa</title><link rel="icon" sizes="16x16 32x32 48x48" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" title="Atom feed of Shuhei Kagawa" href="/blog/feed.xml"><style>:root{--bg-color:#f9f9f9;--text-color:#222;--highlight-color:#095ae8;--code-text-color:var(--code-mono-1);--code-bg-color:#fff;--syntax-hue:230;--syntax-saturation:1%;--syntax-brightness:100%;--code-mono-1:hsl(var(--syntax-hue), 8%, 24%);--code-mono-2:hsl(var(--syntax-hue), 6%, 44%);--code-mono-3:hsl(var(--syntax-hue), 4%, 64%);--code-hue-1:hsl(198, 99%, 37%);--code-hue-2:hsl(221, 76%, 47%);--code-hue-3:hsl(301, 63%, 40%);--code-hue-4:hsl(119, 72%, 31%);--code-hue-5:hsl(5, 68%, 48%);--code-hue-5-2:hsl(344, 84%, 43%);--code-hue-6:hsl(41, 99%, 30%);--code-hue-6-2:hsl(41, 99%, 30%);--body-font-family:"Libre Baskerville",serif;--heading-font-family:"Libre Franklin",sans-serif;--code-font-family:"DM Mono",monospace}body{font-family:"Libre Baskerville",serif;font-family:var(--body-font-family);background:#f9f9f9;background:var(--bg-color);color:#222;color:var(--text-color);padding:0;margin:0;font-size:16px;line-height:1.9}.container{width:700px;padding:0 20px;margin:0 auto}a{color:#095ae8;color:var(--highlight-color);transition:color .5s ease;text-decoration:none}a:hover{text-decoration:underline}.header{padding:1.5em 0 1em;display:flex}.header__title{margin:0 10px 0 0;flex-grow:1;font-size:1em;font-weight:400}.header__title a{color:#222;color:var(--text-color)}.header__nav{flex-grow:0}.menu{list-style-position:outside;list-style-type:none;padding:0;margin:0;text-align:right}.menu__item{display:inline-block;padding:0 0 0 .7em}.menu__item a{color:#222;color:var(--text-color)}.footer{padding:3em 0 4em;text-align:center}.title{font-family:"Libre Franklin",sans-serif;font-family:var(--heading-font-family);font-size:3em;margin:0 0 .2em;line-height:1.1}.title a{color:#222;color:var(--text-color);text-decoration:none}.post,.post-list{padding:1.7em 0 1.25em}.post:after{content:"* * *";font-family:"Libre Franklin",sans-serif;font-family:var(--heading-font-family);font-weight:700;font-size:4.5em;display:block;margin:.9em auto 0;text-align:center;line-height:1}.post .meta{font-size:.75em}.post-list .title{margin-bottom:10px}.post-list-item{line-height:1.6em;padding:10px 0;display:flex}.post-list-item__date{font-size:.8em;width:8em;flex-shrink:0}.post-list-item__title{font-size:1.3em;margin:0;font-family:"Libre Franklin",sans-serif;font-family:var(--heading-font-family);font-weight:700}.post-list-item__title a{text-decoration:none;color:#222;color:var(--text-color)}.content h2,.content h3,.content h4,.content h5,.content h6{font-family:"Libre Franklin",sans-serif;font-family:var(--heading-font-family);margin:1em 0 0 0}.content h2{font-size:2.2em;line-height:1.1}.content h3{font-size:1.6em;line-height:1.3}.content h4{font-size:1.2em}.content img{max-width:100%;height:auto}.content p{margin:1.15em 0}.img-wrapper{display:block;text-align:center}.comments{margin-bottom:3em}ol,ul{list-style-position:outside;padding-left:1.4em}.table-wrapper{overflow-x:auto;margin:1.15em 0}.table-wrapper table{border-collapse:collapse;margin:0;width:100%}tr{vertical-align:top}th{font-weight:400;text-align:left}tbody{border-top:1px solid #333;border-bottom:1px solid #333;padding:.5em 0}td,th{padding-right:1em}code{color:#383942;color:var(--code-text-color);background-color:#fff;background-color:var(--code-bg-color);font-size:.9em;font-family:"DM Mono",monospace;font-family:var(--code-font-family);padding:0 .3em}.code__filename{display:inline-block;margin-bottom:13px;padding:5px 10px;font-size:.85em;background-color:#666}.hljs{display:block;line-height:1.5em;padding:1em 20px;overflow-x:auto;-webkit-overflow-scrolling:touch;color:#383942;color:var(--code-text-color);background-color:#fff;background-color:var(--code-bg-color)}.hljs-comment,.hljs-quote{color:#696b76;color:var(--code-mono-2);font-style:italic}.hljs-doctag,.hljs-formula,.hljs-keyword{color:#a625a4;color:var(--code-hue-3)}.hljs-deletion,.hljs-name,.hljs-section,.hljs-selector-tag,.hljs-subst{color:#cd3527;color:var(--code-hue-5)}.hljs-literal{color:#0083bb;color:var(--code-hue-1)}.hljs-addition,.hljs-attribute,.hljs-meta-string,.hljs-regexp,.hljs-string{color:#188716;color:var(--code-hue-4)}.hljs-built_in,.hljs-class .hljs-title{color:#986800;color:var(--code-hue-6-2)}.hljs-attr,.hljs-number,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-pseudo,.hljs-template-variable,.hljs-type,.hljs-variable{color:#986800;color:var(--code-hue-6)}.hljs-bullet,.hljs-link,.hljs-meta,.hljs-selector-id,.hljs-symbol,.hljs-title{color:#1c56d2;color:var(--code-hue-2)}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.hljs-link{text-decoration:underline}blockquote{font-style:italic;padding:0 0 0 2em;margin:1.5em 0}blockquote p:first-child:before{content:open-quote;font-family:serif;font-size:3em;font-weight:700;line-height:.1em;margin-right:.2em;vertical-align:-.4em}blockquote cite{color:#999990}blockquote cite:before{content:"- "}.pagination{list-style-position:outside;list-style-type:none;padding:0;margin-top:20px;display:flex;justify-content:space-between}.pagination__next-page,.pagination__prev-page{width:46%}.pagination__next-page{text-align:right}.footer-nav{text-align:center}@media only screen and (max-width:767px){body{font-size:15px;line-height:1.65}.container{width:auto}.post,.post-list{padding-top:10px}.post-list-item{display:block}.hljs{margin-left:-20px;margin-right:-20px;padding:1.4em 20px;border-radius:0}li .hljs{margin-left:0}.img-wrapper{margin-left:-20px;margin-right:-20px}}@font-face{font-family:'DM Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/dmmono/v5/aFTU7PB1QTsUX8KYthSQBK6PYK3EXw.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'DM Mono';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/dmmono/v5/aFTU7PB1QTsUX8KYthqQBK6PYK0.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Libre Baskerville';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/librebaskerville/v9/kmKhZrc3Hgbbcjq75U4uslyuy4kn0qNcWx8QDO-WyrubOA.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Libre Baskerville';font-style:italic;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/librebaskerville/v9/kmKhZrc3Hgbbcjq75U4uslyuy4kn0qNcWxEQDO-Wyrs.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Libre Baskerville';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/librebaskerville/v9/kmKnZrc3Hgbbcjq75U4uslyuy4kn0qNXaxMaC82U-ro.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Libre Baskerville';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/librebaskerville/v9/kmKnZrc3Hgbbcjq75U4uslyuy4kn0qNZaxMaC82U.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Libre Franklin';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/librefranklin/v7/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkD9DPTedX18mETQw.woff) format('woff');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Libre Franklin';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/librefranklin/v7/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkDtDPTedX18mETQw.woff) format('woff');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Libre Franklin';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/librefranklin/v7/jizOREVItHgc8qDIbSTKq4XkRg8T88bjFuXOnduhycKkANDPTedX18mE.woff) format('woff');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style><meta name="description" content="A personal website of Shuhei Kagawa. I write mostly on web technologies and life."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@shuheikagawa"><meta property="og:title" content="Shuhei Kagawa"><meta property="og:site_name" content="Shuhei Kagawa"><meta property="og:description" content="A personal website of Shuhei Kagawa. I write mostly on web technologies and life."></head><body><div class="container"><header class="header"><h1 class="header__title"><a href="/">Shuhei Kagawa</a></h1><nav class="header__nav"><ul class="menu"><li class="menu__item"><a href="/about/">About</a></li><li class="menu__item"><a href="/blog/archives/">All posts</a></li></ul></nav></header><div class="main"><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2019/02/18/2018-in-review/">2018 in review</a></h1><div class="meta"><span class="date">Feb 18, 2019</span> - Review</div></div><div class="content"><div><p>Looking back 2018, it flew like an arrow. It was so fast that it's already in February 2019!</p><p><span class="img-wrapper"><picture><source type="image/avif" srcset="/cached/47e705db-700.avif 700w, /cached/47e705db-900.avif 900w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><source type="image/webp" srcset="/cached/47e705db-700.webp 700w, /cached/47e705db-900.webp 900w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><source type="image/jpeg" srcset="/cached/47e705db-700.jpeg 700w, /cached/47e705db-900.jpeg 900w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><img src="/cached/47e705db-700.jpeg" width="700" height="525" alt="Sunset at Tempelhof in April" loading="lazy" decoding="async" style="background-size: cover; background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgIHZpZXdCb3g9IjAgMCA5IDciPgogICAgPGZpbHRlciBpZD0iYiIgY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzPSJzUkdCIj4KICAgICAgPGZlR2F1c3NpYW5CbHVyIHN0ZERldmlhdGlvbj0iLjUiPjwvZmVHYXVzc2lhbkJsdXI+CiAgICAgIDxmZUNvbXBvbmVudFRyYW5zZmVyPgogICAgICAgIDxmZUZ1bmNBIHR5cGU9ImRpc2NyZXRlIiB0YWJsZVZhbHVlcz0iMSAxIj48L2ZlRnVuY0E+CiAgICAgIDwvZmVDb21wb25lbnRUcmFuc2Zlcj4KICAgIDwvZmlsdGVyPgogICAgPGltYWdlIGZpbHRlcj0idXJsKCNiKSIgeD0iMCIgeT0iMCIKICAgICAgaGVpZ2h0PSIxMDAlIiB3aWR0aD0iMTAwJSIKICAgICAgeGxpbms6aHJlZj0iZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBa0FBQUFIQ0FJQUFBQlYrZkEzQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUF6MGxFUVZRSTF3SEVBRHYvQUpHU2pLU2xuTFcwcDhmRnRMUzJyS0Ntb1pxaG5KaWRtSXFOaVFDVWw0NjF0S2JOeWJUWjFMelgwTG5JeDdPN3ZhNnRzS0tjbnBFQW9aMkt0SzZYMU1hbThkZXEvZWF5OE5xcjNNMm8wOG1teExxWUFKaUVaTFdhZEx1YmM4NmhiZW0rZjlPbmJyaVdhNm1SYXArSlpRQVBEd2thR0JFaUhSY3JJeHRFTFIweUpoc2dIQmNaRnhNV0ZoSUFEdzRMRFE0TER3NE1GeFVTSXgwWEhoa1ZGeFFSRkJNUkVSRVFBQXdOQ3cwTUN3ME5DeE1TRGh3WEV4c1lFeFVURUJJUkR4RVFEdVl3VHZyK1BSWlBBQUFBQUVsRlRrU3VRbUNDIj4KICAgIDwvaW1hZ2U+CiAgPC9zdmc+')"></picture></span></p><h2>Move</h2><p>We had lived in an apartment on the border of Schöneberg and Wilmersdorf for 2 years, and decided to move out at the end of October without extending the contract. We spent two or three months for flat search, and a month and a half for moving, buying furniture and setting up the new apartment. After all, we like the new area and are looking forward to spend time on the balcony in the summer.</p><p>In the meanwhile, I got my left arm injured and it took a few months to recover.</p><h2>Travel</h2><p>I visited two new countries and seven new cities. I wanted to visit a few more countries, but could not manage mainly because of the moving.</p><ul><li>Tokyo, Japan in Feburary</li><li>Spreewald, Germany in March</li><li>Amsterdam, Netherlands for React Amsterdam in April</li><li>Leipzig, Germany in May</li><li>Vienna, Austria for a wedding party in July</li><li>München, Germany for Oktoberfest in September</li><li>Köln and Düsseldorf, Germany in November</li></ul><h2>German language</h2><p>After finishing an A2 course at office, I started a B1 course at <a href="https://www.speakeasysprachzeug.de/en">Speakeasy</a>. I felt that I should have taken A2 again... In the end, I was distracted by something else and stopped going to the course.</p><h2>Work</h2><p>It has been 2 years since I started working at Zalando. 2017 was about architecture migration from a monolith to microservices. 2018 was about optimization (and the next migration already started...).</p><p>In addition to front-end tasks, I focused more on non-feature stuff.</p><p>In the first half of the year, I focused on web (frontend) performance optimization. My team's work was featured in a blog post, <a href="https://jobs.zalando.com/tech/blog/loading-time-matters/">Loading Time Matters</a>, on the company blog.</p><p>In June, my team had a series of incidents on one of our applications, but we didn't know why. It opened a door of learning for me. I dug into Node.js internals and Linux network stack. I was lucky enough to find <a href="http://www.brendangregg.com/sysperfbook.html">Systems Performance by Brendan Gregg</a>, which is one of my all-time favorite technical books. As a by-product of the research/learning, I profiled Node.js servers on production and made some performance improvements. Wrote about it on <a href="/blog/2018/09/16/node-js-under-a-microscope/">Node.js under a Microscope: CPU FlameGraph and FlameScope</a>.</p><h2>Side projects</h2><p>I didn't worked on many side projects in 2018. Instead, I learned a lot of low-level stuff. Network, Linux, Node.js. I put some of what I learned into <a href="https://github.com/shuhei/knowledge">the knowledge repo</a> inspired by <a href="https://github.com/yoshuawuyts/knowledge">yoshuawuyts/knowledge</a>. Also, as a permanent solution for the issue at work, I wrote a library to keep Node.js app resilient against DNS timeouts, <a href="https://github.com/shuhei/pollen">pollen</a>. It's been working without issues for 1.5 months!</p><p>Some other unfinished pieces:</p><ul><li>Wrote some Haskell for <a href="https://github.com/shuhei/elm-compiler/pull/1">a GLSL parser</a> in the Elm compiler with <a href="https://github.com/w0rm">@w0rm</a>, but it's pending</li><li>Experimented Node.js profiling at <a href="https://github.com/shuhei/perf-playground">perf-playground</a></li><li>Played around with image formats at <a href="https://github.com/shuhei/incomplete-image-parser">incomplete-image-parser</a></li><li>Tried to write a Node.js profiler inspired by <a href="https://github.com/rbspy/rbspy">rbspy</a>, but gave up to figure out memory layout of V8 objects</li><li>Investigated an issue with <a href="https://github.com/facebook/react/issues/11538#issuecomment-390386520">React + Google Translate</a></li></ul><h2>2019</h2><p>In 2018, I focused on tiny things such as shaving hundreds of milliseconds. In 2019, I would like to be more open. Try new things. Travel more.</p></div></div></div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2018/12/29/histogram-for-time-series-metrics-on-node-js/">Histogram for time-series metrics on Node.js</a></h1><div class="meta"><span class="date">Dec 29, 2018</span> - Node.js</div></div><div class="content"><div><h2>The "metrics" library</h2><p>I have been using <a href="https://github.com/mikejihbe/metrics">metrics</a> library for application metrics of Node.js applications at work. It was already widely used in the company when I joined, and I kept using it without questioning much.</p><p>The <a href="https://github.com/mikejihbe/metrics">metrics</a> library was ported from <a href="https://github.com/dropwizard/metrics">Dropwizard metrics</a>, which is a widely-used metrics library for Java and also called as Coda Hale metrics, Yammer metrics, or Metrics Core. It supports various metrics types like Counter, Gauge, Histogram, Meter (a combination of Counter and Histogram), etc., and nice reporting abstraction.</p><p>Just before my last working day of 2018, I saw a weird chart with a p99.9 response time metric with only around 50 data points per minute. Outliers were staying for ~15 minutes (much longer than expected) and suddenly disappearing. I thought I was misusing the library. That's why I started reading the source code of <a href="https://github.com/mikejihbe/metrics">metrics</a> library, especially <code>Histogram</code>.</p><h2>EDS-based histogram</h2><p>The <code>metrics</code> library uses <a href="https://github.com/mikejihbe/metrics/blob/v0.1.20/stats/exponentially_decaying_sample.js">Exponentially Decaying Sample (EDS)</a> for <code>Histogram</code>. The name is intimidating, but the implementation is not so complicated.</p><p>It sets a priority to each value based on its timing and <em>some randomness</em>, and values of top-1028 priorities survive (by default). As a result, the chance of a value's survival decays as time goes by.</p><p>It seems to have a problem that the influence of an old value stays longer than expected, which was fixed in the Java implementation after the <code>metrics</code> library was ported to JavaScript. Maybe I can port the fix to the JavaScript implementation?</p><p>But, wait. Why do I need the decay at all? Most of my use cases of the histogram are to plot percentiles of response times. The data points are per minute. All I want for each data point is percentiles of all the response times <em>measured in the last minute</em>. I don't need response times from previous minutes because they are already plotted on the chart. Also, I don't want values in the last half of the minute to have more influence than values in the first half. So, <em>I don't need the decay effect at all</em>.</p><p>In addition to that, EDS randomly ignores values. Yes, it <em>samples</em>. Random sampling is a problem because I'm interested in a small number of outliers.</p><h2>HDR histogram</h2><p>I tweeted about these issues, and <a href="https://twitter.com/cbirchall/status/1077526632951414784">my former colleague @cbirchall (Thanks!) suggested</a> to take a look at <a href="https://github.com/HdrHistogram/HdrHistogram">HdrHistogram</a>. I don't understand how it works (yet), but it claims to keep accuracy without sacrificing memory footprint and performance.</p><p><a href="https://medium.com/hotels-com-technology/your-latency-metrics-could-be-misleading-you-how-hdrhistogram-can-help-9d545b598374">Your Latency Metrics Could Be Misleading You — How HdrHistogram Can Help</a> by Will Tomlin on the Hotels.com Technology Blog illustrates shortcomings of the EDS-based histogram and advantages of the HDR histogram pretty well.</p><p>OK, I'm sold.</p><h2>Benchmark on Node.js</h2><p>Then, how can I use HDR Histogram on Node.js? I found three implementations:</p><ul><li><a href="https://github.com/HdrHistogram/HdrHistogramJS">hdr-histogram-js</a>: JS implementation in the same GitHub org as the Java implementation</li><li><a href="https://github.com/mcollina/native-hdr-histogram">native-hdr-histogram</a>: A binding to a C implementation</li><li><a href="https://github.com/kiggundu/node-hdr-histogram">node-hdr-histogram</a>: A binding to the Java implementation</li></ul><p>Also EDS-based histogram implementations:</p><ul><li><a href="https://github.com/mikejihbe/metrics">metrics</a>: The library I'm using at work</li><li><a href="https://github.com/yaorg/node-measured/tree/master/packages/measured-core">measured-core</a>: Actively maintained and widely used by Node.js developers (<a href="https://twitter.com/_vigneshh/status/1078287577394880512">Thanks @_vigneshh for letting me know!</a>)</li></ul><p>I compared them, excluding <code>node-hdr-histogram</code> because I think it's an overkill to run JVM only for metrics (and won't perform well anyway). The benchmark code is on <a href="https://gist.github.com/shuhei/3a747b26b62242ae795616b04c24024f">a gist</a>, and here is the result on Node.js 10.14.2.</p><p>Adding 10K values to a histogram:</p><div class="table-wrapper"><table><thead><tr><th>implementation</th><th>ops/sec</th></tr></thead><tbody><tr><td><code>metrics</code></td><td>173 ops/sec ±2.00% (80 runs sampled)</td></tr><tr><td><code>measured</code></td><td>421 ops/sec ±1.19% (90 runs sampled)</td></tr><tr><td><code>hdr-histogram-js</code></td><td>1,769 ops/sec ±1.84% (92 runs sampled)</td></tr><tr><td><code>native-hdr-histogram</code></td><td>1,516 ops/sec ±0.82% (92 runs sampled)</td></tr></tbody></table></div><p>Extracting 12 different percentiles from a histogram:</p><div class="table-wrapper"><table><thead><tr><th>implementation</th><th>ops/sec</th></tr></thead><tbody><tr><td><code>metrics</code></td><td>1,721 ops/sec ±1.93% (92 runs sampled)</td></tr><tr><td><code>measured</code></td><td>3,709 ops/sec ±0.78% (93 runs sampled)</td></tr><tr><td><code>measured</code> (weighted percentiles)</td><td>2,383 ops/sec ±1.30% (90 runs sampled)</td></tr><tr><td><code>hdr-histogram-js</code></td><td>3,509 ops/sec ±0.61% (93 runs sampled)</td></tr><tr><td><code>native-hdr-histogram</code></td><td>2,760 ops/sec ±0.76% (93 runs sampled)</td></tr></tbody></table></div><p>According to the result, <code>hdr-histogram-js</code> is accurate and fast enough. Check out <a href="https://gist.github.com/shuhei/3a747b26b62242ae795616b04c24024f">the gist</a> for more details!</p><h2>Reset strategy</h2><p>While HDR Histogram can keep numbers more accurately than Exponentially Decaying Sample, it doesn't throw away old values by itself. We need a strategy to remove old values out of it. In a sense, EDS is a reset strategy. If we don't use it, we need another one.</p><p><a href="https://github.com/vladimir-bukhtoyarov/rolling-metrics/blob/e1bff04f05743b642585897182bb6807b1bdfce2/histograms.md#configuration-options-for-evicting-the-old-values-of-from-reservoir">Documentation of rolling-metrics library</a> lists up strategies and their trade-offs.</p><ul><li>Reset on snapshot</li><li>Reset periodically</li><li>Reset periodically by chunks (rolling time window)</li><li>Never reset</li></ul><p><em>Reset on snapshot</em> looks a bit hacky (we need to keep metrics collection only once in an interval) but should be easy to implement and practical. <em>Rolling time window</em> looks more rigorous, but a bit tedious to implement, especially about choosing the right parameters.</p><p>I made a quick survey of popular libraries and frameworks.</p><ul><li>Hysterix: <a href="https://github.com/Netflix/Hystrix/blob/v1.5.18/hystrix-core/src/main/java/com/netflix/hystrix/metric/consumer/RollingCommandLatencyDistributionStream.java">HdrHistogram + rolling time window</a></li><li>Finagle: <a href="https://github.com/twitter/finagle/blob/finagle-18.12.0/finagle-core/src/main/scala/com/twitter/finagle/util/WindowedPercentileHistogram.scala">HdrHistogram + rolling time window</a></li><li>Resilience4j: Uses Prometheus?</li><li>Prometheus: Supports <a href="https://prometheus.io/docs/practices/histograms/">Histogram and Summary</a> by its own implementation</li><li><a href="https://github.com/vladimir-bukhtoyarov/rolling-metrics">rolling-metrics</a>: Supports HdrHistogram and multiple strategies including rolling time window.</li><li><a href="https://github.com/erikvanoosten/metrics-scala">metrics-scala</a>: Supports HdrHistogram + only reset on snapshot strategy. Depends on <a href="https://bitbucket.org/marshallpierce/hdrhistogram-metrics-reservoir">hdrhistogram-metrics-reservoir</a>.</li></ul><p><em>Rolling time window</em> strategy seems to be most popular, but I couldn't find a consensus on default parameters (length of the time window, bucket size, etc.). For the next step, I'll probably start with <em>reset on snapshot</em> strategy and see if it works well.</p><p><em>Update on Jan 11, 2019:</em> I wrote <a href="https://github.com/shuhei/rolling-window">a package to use HDR histogram with rolling time window</a>.</p><h2>Conclusion</h2><p>HDR Histogram is more accurate than EDS-based Histogram for tracking response times in a time series. <a href="https://github.com/HdrHistogram/HdrHistogramJS">hdr-histogram-js</a> is accurate and performant. It seems to be the best option on Node.js. We need a way to remove old values from a histogram. <em>Reset on snapshot</em> is easy and practical, but <em>rolling time window</em> is more rigorous.</p><p>After the research on this topic, I got an impression that HDR Histogram is well-known in the Java/JVM community, but probably not so much in other communities. I made a benchmark on Node.js in this post, but it might be useful to review your metrics implementation on other programming languages or platforms as well.</p></div></div></div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2018/09/16/node-js-under-a-microscope/">Node.js under a microscope: CPU FlameGraph and FlameScope</a></h1><div class="meta"><span class="date">Sep 16, 2018</span> - Node.js, Linux</div></div><div class="content"><div><p>Last week, I had an opportunity to talk about profiling Node.js applications on production at an internal guild meeting at work. Here is a written version of it plus some additional information.</p><h2>Background</h2><p>I have been working on Node.js microservices, which fetch data from API servers and render HTML with React, at work. We monitor response times at load balancers, in application metrics and with distributed tracing with OpenTracing. One of the microservices had a weird gap between 99 percentile response times of itself and its dependencies. It was spending an extra 500 milliseconds—but I didn't know why.</p><p>My first suspect was the network. It is the place full of uncertainty. After learning and trying different commands and metrics, I took <code>tcpdump</code> and checked packets one by one with my eyes and a script. There were no significant delays that I had expected. So I had to stop blaming the network—or <em>someone else</em>.</p><h2>CPU profiling with the Linux <code>perf</code> command</h2><p>Because the weird latency was happening in the application itself, I wanted to know what's going on in it. There are mainly two ways to achieve this: profiling and tracing. Profiling records some samples and tracing records everything. I wanted to do it <em>on production</em>, so profiling was naturally a good fit because of its smaller overhead.</p><p>For Node.js, there are mainly two different tools. One is <a href="https://github.com/v8/v8/wiki/V8-Profiler">V8 profiler</a>, and the other is <a href="https://perf.wiki.kernel.org/index.php/Main_Page">Linux perf</a>. V8 profiler uses the profiler provided by V8. It covers all JavaScript executions and V8 native functions. It works on non-Linux operating systems. If you use non-Linux machines, it might be pretty handy. On the other hand, Linux <code>perf</code> can profile almost anything including Linux kernel, libuv, and all processes on your OS with minimal overhead. However, as the name suggests, it works only on Linux. According to <a href="https://github.com/nodejs/diagnostics/issues/148">Node CPU Profiling Roadmap</a>, it seems that V8 profiler is the one officially supported by the V8 team, but Linux <code>perf</code> will keep working for a while. After all, I picked Linux <code>perf</code> because of low performance-overhead and small intervention to applications.</p><p>Linux <code>perf record</code> records stack traces into a binary file called <code>perf.data</code> by default. The binary file has only addresses and file names of functions. <code>perf script</code> converts the stack traces into a human-readable text file adding function names from program binaries and symbol map files.</p><pre><code class="hljs sh"><span class="hljs-comment"># Install dependencies for `perf` command</span>
sudo apt-get install linux-tools-common linux-tools-$(uname -r)
<span class="hljs-comment"># Test `perf` command</span>
sudo perf top

<span class="hljs-comment"># Record stack traces 99 times per second for 30 seconds</span>
sudo perf record -F 99 -p <span class="hljs-variable">${pid}</span> -g -- sleep 30s
<span class="hljs-comment"># Generate human readable stack traces</span>
sudo perf script &gt; stacks.<span class="hljs-variable">${pid}</span>.out
</code></pre><p>Now we have human-readable stack traces, but it's still hard to browse thousands of stack traces and get insights from them. How can we efficiently analyze them?</p><h2>CPU Flame Graph</h2><p><a href="http://www.brendangregg.com/flamegraphs.html">CPU Flame Graph by Brendan Gregg</a> is a great way of visualizing stack traces. It aggregates stack traces into one chart. Frequently executed functions are shown wider and rarely executed functions are narrower in the chart.</p><p><span class="img-wrapper"><picture><source type="image/avif" srcset="/cached/e2370854-700.avif 700w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><source type="image/webp" srcset="/cached/e2370854-700.webp 700w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><img src="/cached/e2370854-700.png" width="700" height="390" alt="CPU Flame Graph" loading="lazy" decoding="async" style="background-size: cover; background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgIHZpZXdCb3g9IjAgMCAxMCA2Ij4KICAgIDxmaWx0ZXIgaWQ9ImIiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CiAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249Ii41Ij48L2ZlR2F1c3NpYW5CbHVyPgogICAgICA8ZmVDb21wb25lbnRUcmFuc2Zlcj4KICAgICAgICA8ZmVGdW5jQSB0eXBlPSJkaXNjcmV0ZSIgdGFibGVWYWx1ZXM9IjEgMSI+PC9mZUZ1bmNBPgogICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+CiAgICA8L2ZpbHRlcj4KICAgIDxpbWFnZSBmaWx0ZXI9InVybCgjYikiIHg9IjAiIHk9IjAiCiAgICAgIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiCiAgICAgIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQW9BQUFBR0NBSUFBQUIxa3BpUkFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFBeFVsRVFWUUkxd0c2QUVYL0FQYjE5Zkh1Ni9UMDgvanA1S25jbWJQTnJmdng4L242K3ZuNStQbjUrUUR5dWJuc2o1bnJocFhmblppUjVJNlYyS1Q0OGZMNit2cjUrZm41K2ZnQW5NQ0liYnAwYWJkeWU3bHhqTmwvWU82VzhmVHYrL2o2K1BqNCtmcjdBSWVjYlpDU2JJNlliNStiY01hUGFzcDdmUFgwOC9yLy92ajU4L2Z0M3dEcFVXdjBXblh6VjNUNVhYWHhaSEh2WVhqdnM3N3h3OG53dExUc3VhSUE1cXVHNjdHTjY3R003YkdPN2ErTzc3R080Nm1HNUttSDU2bUU3c1NxbDNLSVpGeEh4c0FBQUFBQVNVVk9SSzVDWUlJPSI+CiAgICA8L2ltYWdlPgogIDwvc3ZnPg==')"></picture></span><em>A CPU Flame Graph from <a href="https://github.com/shuhei/perf-playground">a sample application</a></em></p><p>I found some insights about the application on production with CPU Flame Graph:</p><ul><li>React server-side rendering is considered to be a very CPU-intensive task that blocks Node.js event loop. However, <code>JSON.parse()</code> was using 3x more CPU than React—it might be because we had already optimized React server-side rendering though.</li><li>Gzip decompression was using the almost same amount of CPU as React server-side rendering.</li></ul><p>There are a few tools like <a href="https://github.com/brendangregg/FlameGraph">FlameGraph</a> and <a href="https://github.com/davidmarkclements/0x">0x</a> to generate CPU Flame Graph from Linux <code>perf</code> stack traces. However, I eventually didn't need them because FlameScope, which I'll explain next, can generate CPU Flame Graph too.</p><h2>FlameScope</h2><p><a href="https://github.com/Netflix/flamescope">FlameScope by Netflix</a> is another great tool for visualizing stack traces in a time-series. It shows a heatmap out of stack traces. Each cell represents a short amount of time, 20 ms if 50 cells per second, and its color represents how many times the process was on-CPU. It visualizes patterns of your application's activity.</p><p><span class="img-wrapper"><picture><source type="image/avif" srcset="/cached/33722f51-700.avif 700w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><source type="image/webp" srcset="/cached/33722f51-700.webp 700w" sizes="(max-width: 767px) calc(100vw - 40px), 700px"><img src="/cached/33722f51-700.png" width="700" height="481" alt="FlameScope" loading="lazy" decoding="async" style="background-size: cover; background-image: url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgIHZpZXdCb3g9IjAgMCAxMCA2Ij4KICAgIDxmaWx0ZXIgaWQ9ImIiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0ic1JHQiI+CiAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249Ii41Ij48L2ZlR2F1c3NpYW5CbHVyPgogICAgICA8ZmVDb21wb25lbnRUcmFuc2Zlcj4KICAgICAgICA8ZmVGdW5jQSB0eXBlPSJkaXNjcmV0ZSIgdGFibGVWYWx1ZXM9IjEgMSI+PC9mZUZ1bmNBPgogICAgICA8L2ZlQ29tcG9uZW50VHJhbnNmZXI+CiAgICA8L2ZpbHRlcj4KICAgIDxpbWFnZSBmaWx0ZXI9InVybCgjYikiIHg9IjAiIHk9IjAiCiAgICAgIGhlaWdodD0iMTAwJSIgd2lkdGg9IjEwMCUiCiAgICAgIHhsaW5rOmhyZWY9ImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQW9BQUFBR0NBWUFBQUQ2OEEvR0FBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFBd1VsRVFWUUkxeDJQNjNLQ01CQ0ZlZjlYNjlTcFJTNVZRQzZLaE1RSVNtTWcySzlwZjV6NVp2YWNPYnNiUEs0S2M5Tk1ubmVsR0pYa2Nqb2gycGFoRnd4MWhhNXJnclhNTVZuS2Q1SGg4cHkxTHBCSjVMWERmVVc4bWlPckVnU3VLdERSbHZwamc5aUdtRElEY1FadjJ1TEE4ZjJOeXo3MVFkOUFsdkJ6YnBCUlRCZUhpSGhISG40eUhWTHUrNFNITHd2Y1ZmS1NIYzdmdUhRZDZKNnhxWkJWaWUxYXY3YkhEWnJBV010a0RFOVBPODg4eDRIWlA3VG9HL095L00vKzlBdlJjdC9UbHhFdzRRQUFBQUJKUlU1RXJrSmdnZz09Ij4KICAgIDwvaW1hZ2U+CiAgPC9zdmc+')"></picture></span><em>Image from <a href="https://github.com/Netflix/flamescope">Netflix/flamescope</a></em></p><p>If you select a time range on the heatmap, FlameScope shows you a CPU Flame Graph of the range. It allows you to examine what happened when in details.</p><p>To use FlameScope, check out the repository and run the python server. Then put stack trace files from <code>perf script</code> into <code>examples</code> directory, and open <code>http://localhost:5000</code>.</p><p>I found a couple of exciting insights about the application on production using this tool.</p><h3>Example 1: Heavy tasks in the master process</h3><p>The application used <a href="https://nodejs.org/api/cluster.html">the <code>cluster</code> module</a> to utilize multiple CPU cores. FlameScope showed that the master process was not busy for most of the time, but it occasionally kept using CPU for 1.5 seconds continuously! FlameScope showed that it was caused by metrics aggregation.</p><p>The master process was aggregating application metrics from worker processes, and it was responding to metrics collectors a few times in a minute. When the metrics collectors asked for data, the master process calculated percentiles of response times and prepared a JSON response. The percentile calculation was taking long time because the application had a lot of metrics buckets and the library that we used was using <code>JSON.stringify()</code> and <code>JSON.parse()</code> to deep-copy objects!</p><h3>Example 2: Frequent garbage collections</h3><p>FlameScope showed that the worker processes were not overloaded for most of the time, but they had a few hundred milliseconds of CPU-busy time in about 10 seconds. It was caused by mark-sweep and mark-compact garbage collections.</p><p>The application had an in-memory fallback cache for API calls that was used only when API calls and retries fail. Even when API had problems, the cache hit rate was very low because of the number of permutations. In other words, it was not used almost at all. It cached large API responses for a while and threw them away after the cache expired. It looked innocent at first glance—but it was a problem for V8's <a href="http://www.memorymanagement.org/glossary/g.html#term-generational-garbage-collection">generational garbage collector</a>.</p><p>The API responses were always promoted to the old generation space causing frequent slow GCs. GC of the old generation is much slower than GC of the young generation. After removing the fallback cache, the application's 99 percentile response time improved by hundreds of milliseconds!</p><h2>Node.js gotchas</h2><p><code>perf script</code> collects symbols for function addresses from program binaries. For Node.js, we need something special because functions are compiled just in time. As far as I know, there are two ways to record symbols:</p><ol><li>Run your Node.js process with <code>--perf-basic-prof-only-functions</code> option. It generates a log file at <code>/tmp/perf-${pid}.map</code>. The file keeps growing. The speed depends on your application, but it was a few megabytes per day for an application at work. Another problem is that functions in V8 keep moving and the addresses in <code>/tmp/perf-${pid}.map</code> get outdated. <a href="https://gist.github.com/shuhei/6c261342063bad387c70af384c6d8d5c">I wrote a script to fix the issue</a>.</li><li>Use <a href="https://github.com/mmarchini/node-linux-perf">mmarchini/node-linux-perf</a>. It generates the same <code>/tmp/perf-${pid}.map</code> as <code>--perf-basic-prof-only-functions</code> does, but on demand. Because it always freshly generates the file, it doesn't contain outdated symbols. It seems to be the way to go, but I haven't tried this on production yet.</li></ol><p>In addition to the above, there are a few more Node.js options that you can use to improve your stack traces—though I haven't tried them on production because the stack traces were already good enough for me:</p><ul><li><code>--no-turbo-inlining</code> turns off function inlining, which is an optimization done by V8. Because function inlining fuses multiple functions into one, it can make it harder to understand stack traces. Turning it off generates more named frames.</li><li><code>--interpreted-frames-native-stack</code> fixes <code>Builtin:InterpereterEntryTrampoline</code> in stack traces. It is available from Node.js 10.4.0. Check out "Interpreted Frames" in <a href="https://github.com/nodejs/diagnostics/issues/148#issuecomment-369348961">Updates from the Diagnostics Summit</a> for more details.</li></ul><h2>Docker gotchas</h2><p>It gets a bit tricky when you are using containers to run your application. There are two ways to use Linux <code>perf</code> with Docker:</p><ol><li>Run <code>perf record</code> and <code>perf script</code> in the same Docker container as your application is running</li><li>Run <code>perf record</code> and <code>perf script</code> in the host OS</li></ol><p>I eventually chose the option 2. I tried the option 1 first but gave up because I was using Alpine Linux as the base image and it was hard to make Linux <code>perf</code> available on it.</p><p>To run <code>perf record</code> in the host OS, we need to figure out <code>pid</code> of the application process in the host.</p><pre><code class="hljs">$ ps ax | grep -n 'node --perf'
21574 pts/0    Sl+    2:53 node --perf-basic-prof-only-functions src/index.js
30481 pts/3    S+     0:00 grep --color=auto node --perf
# or
$ pgrep -f 'node --perf'
21574

$ sudo perf record -F 99 -p 21574 -g -- sleep 30s
</code></pre><p><code>perf script</code> collects symbols from binaries and symbol files to get human-readable function names. It needs to be able to read the binaries whose functions were recorded with <code>perf script</code> and <code>/tmp/${pid}.map</code> files that applications generate. However, <code>perf script</code> in the host OS cannot read them with the same file names as the container can. (It seems that this is not the case anymore with the latest Linux kernel because <a href="https://lkml.org/lkml/2017/7/19/790">its <code>perf</code> command knows containers</a>. But it was the case for me because I was not using the latest kernel.)</p><p>I learned how to overcome the issue from <a href="http://blog.alicegoldfuss.com/making-flamegraphs-with-containerized-java/">Making FlameGraphs with Containerized Java</a>. I just copied necessary files from the container to the host.</p><pre><code class="hljs sh"><span class="hljs-comment"># Horrible hack! Binaries to be used depend on your set up. `perf script` tells you what it wants if anything is missing.</span>
sudo docker cp mycontainer:/usr/bin/node /usr/bin/node
sudo docker cp mycontainer:/lib/ld-musl-x86_64.so.1 /lib/ld-musl-x86_64.so.1
sudo docker cp mycontainer:/usr/lib/libstdc++.so.6.0.22 /usr/lib/libstdc++.so.6.0.22
</code></pre><p>To copy symbol map files, we need to find the <code>pid</code> in the container. We can do it by checking <code>/proc/${host_pid}/status</code>.</p><pre><code class="hljs">$ cat /proc/21574/status | grep NSpid
NSpid:  21574   6
$ sudo docker cp mycontainer:/tmp/perf-6.map /tmp/perf-21574.map
</code></pre><p>Now everything is ready! Then we can use <code>perf script</code> as usual.</p><pre><code class="hljs sh">sudo perf script &gt; stacks.<span class="hljs-variable">${pid}</span>.out
</code></pre><p>I set up <a href="https://github.com/shuhei/perf-playground">a sample project</a> for profiling a Node.js application on Docker. It was nice to practice profiling a bit before doing it on production!</p><h2>Conclusion</h2><p>Linux <code>perf</code> provides great observability to Node.js applications on production. Tools like CPU Flame Graph and FlameScope helped me to identify performance bottlenecks.</p><p>There are some gotchas to profile Node.js applications on Docker with Linux <code>perf</code>. It took some time for me to figure out how to do it because Node.js and Linux evolve day by day and I couldn't find many up-to-date resources online. I hope this post is helpful!</p></div></div></div><ul class="pagination"><li class="pagination__prev-page"><a href="/blog/pages/5/">Newer posts</a></li><li class="pagination__next-page"><a href="/blog/pages/7/">Older posts</a></li></ul><nav class="footer-nav"><a href="/blog/archives/">All posts</a></nav></div><footer class="footer">© Shuhei Kagawa</footer></div></body></html>