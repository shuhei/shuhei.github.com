{"site":{"title":"Shuhei Kagawa","author":"Shuhei Kagawa","perPage":3,"newPageExtension":"markdown","blogDir":"blog","sourceDir":"source","layoutDir":"_layouts","postDir":"_posts","cssFiles":["node_modules/highlight.js/styles/monokai-sublime.css","source/_css/style.css"]},"post":{"layout":"post","title":"Getting Memory Usage in Linux and Docker","date":"2017-05-28 16:28","comments":true,"categories":["Linux","Docker"],"url":"/blog/2017/05/27/memory-usage/","content":"<p>Recently I started monitoring a Node.js app that we have been developing at work. After a while, I found that its memory usage % was growing slowly, like 20% in 3 days. The memory usage was measured in the following Node.js code.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> os = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'os'</span>);\n\n<span class=\"hljs-keyword\">const</span> total = os.totalmem();\n<span class=\"hljs-keyword\">const</span> free = os.freemem();\n<span class=\"hljs-keyword\">const</span> usage = (free - total) / total * <span class=\"hljs-number\">100</span>;</code></pre><p>So, they are basically from OS, which was <a href=\"https://alpinelinux.org/\">Alpine Linux</a> on Docker in this case. Luckily I also had memory usages of application processes recorded, but they were not increasing. Then why is the OS memory usage increasing?</p>\n<h2 id=\"buffers-and-cached-memory\">Buffers and Cached Memory</h2>\n<p>I used <code>top</code> command with <code>Shift+m</code> (sort by memory usage) and compared processes on a long-running server and ones on a newly deployed server. Processes on each side were almost same. The only difference was that <code>buffers</code> and <code>cached Mem</code> were high on the long-running one.</p>\n<p>After some research, or googling, I concluded that it was not a problem. Most of <code>buffers</code> and <code>cached Mem</code> are given up when application processes claim more memory.</p>\n<p>Actually <code>free -m</code> command provides a row for <code>used</code> and <code>free</code> taking buffers and cached into consideration.</p>\n<pre><code class=\"hljs \">$ free -m\n             total  used  free  shared  buffers cached\nMem:          3950   285  3665     183       12    188\n-/+ buffers/cache:    84  3866\nSwap:         1896     0  1896</code></pre><p>So, what are they actually? According to <a href=\"http://man7.org/linux/man-pages/man5/proc.5.html\">the manual of <code>/proc/meminfo</code></a>, which is a pseudo file and the data source of <code>free</code>, <code>top</code> and friends:</p>\n<pre><code class=\"hljs \">Buffers %lu\n       Relatively temporary storage for raw disk blocks that\n       shouldn't get tremendously large (20MB or so).\n\nCached %lu\n       In-memory cache for files read from the disk (the page\n       cache).  Doesn't include SwapCached.</code></pre><p>I am still not sure what exactly <code>Buffers</code> contains, but it contains metadata of files, etc. and it&#39;s relatively trivial in size. <code>Cached</code> contains cached file contents, which are called page cache. OS keeps page cache while RAM has enough free space. That was why the memory usage was increasing even when processes were not leaking memory.</p>\n<p>If you are interested, <a href=\"https://www.quora.com/What-is-the-difference-between-Buffers-and-Cached-columns-in-proc-meminfo-output\">What is the difference between Buffers and Cached columns in /proc/meminfo output?</a> on Quora has more details about <code>Buffers</code> and <code>Cached</code>.</p>\n<h2 id=\"memavailable\">MemAvailable</h2>\n<p>So, should we use <code>free + buffers + cached</code>? <code>/proc/meminfo</code> has an even better metric called <code>MemAvailable</code>.</p>\n<pre><code class=\"hljs \">MemAvailable %lu (since Linux 3.14)\n       An estimate of how much memory is available for\n       starting new applications, without swapping.</code></pre><pre><code class=\"hljs \">$ cat /proc/meminfo\nMemTotal:        4045572 kB\nMemFree:         3753648 kB\nMemAvailable:    3684028 kB\nBuffers:           13048 kB\nCached:           193336 kB\n...</code></pre><p>Its background is explained well in <a href=\"https://github.com/torvalds/linux/commit/34e431b0ae398fc54ea69ff85ec700722c9da773\">the commit in Linux Kernel</a>, but essentially it excludes non-freeable page cache and includes reclaimable slab memory. <a href=\"https://github.com/torvalds/linux/blob/v4.12-rc2/mm/page_alloc.c#L4341-L4382\">The current implementation in Linux v4.12-rc2</a> still looks almost same.</p>\n<p>Some implementation of <code>free -m</code> have <code>available</code> column. For example, on Boot2Docker:</p>\n<pre><code class=\"hljs \">$ free -m\n       total  used  free  shared  buff/cache  available\nMem:    3950    59  3665     183         226       3597\nSwap:   1896     0  1896</code></pre><p>It is also <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/mon-scripts.html\">available on AWS CloudWatch metrics</a> via <code>--mem-avail</code> flag.</p>\n<h2 id=\"some-background-about-docker\">Some background about Docker</h2>\n<p>My another question was &quot;Are those metrics same in Docker?&quot;. Before diving into this question, let&#39;s check how docker works.</p>\n<p>According to <a href=\"https://docs.docker.com/engine/docker-overview/#the-underlying-technology\">Docker Overview: The Underlying Technology</a>, processes in a Docker container directly run in their host OS without any virtualization, but they are isolated from the host OS and other containers in effect thanks to these Linux kernel features:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Linux_namespaces\">namespaces</a>: Isolate PIDs, hostnames, user IDs, network accesses, IPC, etc.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cgroups\">cgroups</a>: Limit resource usage</li>\n<li><a href=\"https://en.wikipedia.org/wiki/UnionFS\">UnionFS</a>: Isolate file system</li>\n</ul>\n<p>Because of the namespaces, <code>ps</code> command lists processes of Docker containers in addition to other processes in the host OS, while it cannot list processes of host OS or other containers in a docker container.</p>\n<p><a href=\"https://docs.docker.com/engine/admin/resource_constraints/#memory\">By default, Docker containers have no resource constraints</a>. So, if you run one container in a host and don&#39;t limit resource usage of the container, and this is my case, the container&#39;s &quot;free memory&quot; is same as the host OS&#39;s &quot;free memory&quot;.</p>\n<h2 id=\"memory-metrics-on-docker-container\">Memory Metrics on Docker Container</h2>\n<p>If you want to monitor a Docker container&#39;s memory usage from outside of the container, it&#39;s easy. You can use <code>docker stats</code>.</p>\n<pre><code class=\"hljs \">$ docker stats\nCONTAINER     CPU %  MEM USAGE / LIMIT  MEM %  NET I/O     BLOCK I/O  PIDS\nfc015f31d9d1  0.00%  220KiB / 3.858GiB  0.01%  1.3kB / 0B  0B / 0B    2</code></pre><p>But if you want to get the memory usage in the container or get more detailed metrics, it gets complicated. <a href=\"https://fabiokung.com/2014/03/13/memory-inside-linux-containers/\">Memory inside Linux containers</a> describes the difficulties in details.</p>\n<p><code>/proc/meminfo</code> and <code>sysinfo</code>, which is used by <code>os.totalmem()</code> and <code>os.freemem()</code> of Node.js, are not isolated, you get metrics of host OS if you use normal utilities like <code>top</code> and <code>free</code> in a Docker container.</p>\n<p>To get metrics specific to your Docker container, <a href=\"https://docs.docker.com/engine/admin/runmetrics/\">you can check pseudo files in <code>/sys/fs/cgroup/memory/</code></a>. They are not standardized according to <a href=\"https://fabiokung.com/2014/03/13/memory-inside-linux-containers/\">Memory inside Linux containers</a> though.</p>\n<pre><code class=\"hljs \">$ cat /sys/fs/cgroup/memory/memory.usage_in_bytes\n303104\n$ cat /sys/fs/cgroup/memory/memory.limit_in_bytes\n9223372036854771712</code></pre><p><code>memory.limit_in_bytes</code> returns a very big number if there is no limit. In that case, you can find the host OS&#39;s total memory with <code>/proc/meminfo</code> or commands that use it.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>It was a longer journey than I initially thought. My takeaways are:</p>\n<ul>\n<li>Available Memory &gt; Free Memory</li>\n<li>Use <code>MemAvailable</code> if available (pun intended)</li>\n<li>Processes in a Docker container run directly in host OS</li>\n<li>Understand what you are measuring exactly, especially in a Docker container</li>\n</ul>\n"}}