<!doctype html>
    <html >
      <head>
        <meta charset="utf-8">
        <link rel="preload" href="//fonts.googleapis.com/css?family=Asap:400,700" as="style">
        <link rel="preload" href="/js/index.js" as="script">
        <link rel="preconnect" href="//fonts.gstatic.com" crossorigin>
        <meta name="viewport" content="initial-scale=1">
        <title data-react-helmet="true">Getting Memory Usage in Linux and Docker - Shuhei Kagawa</title>
        <link rel="icons" sizes="16x16 32x32 48x48" href="/favicon.ico">
        <link rel="alternate" type="application/rss+xml" title="RSS Feed for shuheikagawa.com" href="/blog/feed/rss.xml">
        <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Asap:400,700">
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-309586-8', 'shuheikagawa.com');
          ga('send', 'pageview');
        </script>
        <style>.hljs{display:block;overflow-x:auto;padding:.5em;background:#23241f}.hljs,.hljs-subst,.hljs-tag{color:#f8f8f2}.hljs-emphasis,.hljs-strong{color:#a8a8a2}.hljs-bullet,.hljs-link,.hljs-literal,.hljs-number,.hljs-quote,.hljs-regexp{color:#ae81ff}.hljs-code,.hljs-section,.hljs-selector-class,.hljs-title{color:#a6e22e}.hljs-strong{font-weight:700}.hljs-emphasis{font-style:italic}.hljs-attr,.hljs-keyword,.hljs-name,.hljs-selector-tag{color:#f92672}.hljs-attribute,.hljs-symbol{color:#66d9ef}.hljs-class .hljs-title,.hljs-params{color:#f8f8f2}.hljs-addition,.hljs-built_in,.hljs-builtin-name,.hljs-selector-attr,.hljs-selector-id,.hljs-selector-pseudo,.hljs-string,.hljs-template-variable,.hljs-type,.hljs-variable{color:#e6db74}.hljs-comment,.hljs-deletion,.hljs-meta{color:#75715e}body{background-color:#f8f8f2;font-family:Asap,sans-serif;padding:0;margin:0}::-moz-selection{background:#fbf42f}::selection{background:#fbf42f}a{color:#000;transition:color .3s ease}a:hover{color:#999}blockquote{border-left:10px solid #eeeee0;font-style:italic;padding:.1em 1.2em;margin-left:0;quotes:"\201C""\201D""\2018""\2019"}blockquote p:first-child:before{color:#ccccc0;content:open-quote;font-family:serif;font-size:3em;font-weight:700;line-height:.1em;margin-right:.2em;vertical-align:-.4em}blockquote cite{color:#999990}blockquote cite:before{content:"- "}.header{padding:25px 0 10px;text-align:center}.header__title{margin:0 0 15px}.header__title a{text-decoration:none}.menu{list-style-position:outside;list-style-type:none;padding:10px 0;margin:0}.menu__item{display:inline-block;padding:0 20px}.menu__item a{font-weight:700;text-decoration:none}.footer{padding:30px 0;text-align:center}.title a{text-decoration:none}.post,.post-list{background:#fff;border-top:8px solid #fbf52f;padding:30px 0 20px}.post{margin:0 0 40px}.post:last-child{margin-bottom:0}.post .content,.post .post-header{margin:0 auto;width:700px}.post .title{margin:0}.post .meta{color:#999;font-size:small;margin:10px 0 25px}.post-list .title{margin:0 auto 10px;width:700px}.post-list-item{line-height:1.6em;padding:10px 0;margin:0 auto;width:700px}.post-list-item:after{content:"";clear:both;display:block}.post-list-item__date{color:#999;float:left;font-size:small;width:80px}.post-list-item__title{font-size:large;float:left;width:620px;margin:0}.post-list-item__title a{font-weight:700;text-decoration:none}.content{line-height:1.6em}.content img{max-width:100%}.social-buttons{margin:2em 0 0}.comments{margin:0 auto 3em;width:700px}.table-wrapper{overflow-x:auto}table{border-collapse:collapse;margin:2em 0}th{font-weight:400;text-align:left}tbody{border-top:1px solid #333;padding:.5em 0}td,th{padding-right:1em}.hljs{line-height:1.5em;padding:10px 15px;overflow-x:auto}code{background-color:#f8f8f2;padding:.1em .2em;font-size:.85em;font-family:Monaco,'Lucida Console',monospace}.pagination{list-style-position:outside;list-style-type:none;padding:0;margin:-20px auto 0;width:700px}.pagination:after{content:"";clear:both;display:block}.pagination li{float:left;font-weight:700;min-height:1em}.pagination a{text-decoration:none}.pagination__prev-page{float:left;width:35%}.pagination__prev-page a:before{content:"< "}.pagination__next-page{float:right;text-align:right;width:35%}.pagination__next-page a:after{content:" >"}.pagination__archives{text-align:center;width:30%}@media only screen and (max-width:767px){h1{font-size:24px}.comments,.pagination,.post .content,.post .post-header,.post-list .title,.post-list-item{margin-left:20px;margin-right:20px;width:auto}.post-list-item__title{width:100%}.hljs{margin-left:-20px;margin-right:-20px;padding:1.4em 20px}}</style>
      </head>
      <body>
        <div id="container"><div data-reactroot=""><header class="header"><h1 class="header__title"><a href="/">Shuhei Kagawa</a></h1><nav><ul class="menu"><li class="menu__item"><a href="/about/">About</a></li><li class="menu__item"><a href="/works/">Works</a></li><li class="menu__item"><a href="/blog/archives/">Archives</a></li></ul></nav></header><div class="main"><div><div class="post"><div class="post-header"><h1 class="title"><a href="/blog/2017/05/27/memory-usage/">Getting Memory Usage in Linux and Docker</a></h1><div class="meta">@<span class="date">2017-05-28 16:28</span> - <span class="category">Linux</span>, <span class="category">Docker</span></div></div><div class="content"><div><p>Recently I started monitoring a Node.js app that we have been developing at work. After a while, I found that its memory usage % was growing slowly, like 20% in 3 days. The memory usage was measured in the following Node.js code.</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">'os'</span>);

<span class="hljs-keyword">const</span> total = os.totalmem();
<span class="hljs-keyword">const</span> free = os.freemem();
<span class="hljs-keyword">const</span> usage = (free - total) / total * <span class="hljs-number">100</span>;</code></pre><p>So, they are basically from OS, which was <a href="https://alpinelinux.org/">Alpine Linux</a> on Docker in this case. Luckily I also had memory usages of application processes recorded, but they were not increasing. Then why is the OS memory usage increasing?</p>
<h2 id="buffers-and-cached-memory">Buffers and Cached Memory</h2>
<p>I used <code>top</code> command with <code>Shift+m</code> (sort by memory usage) and compared processes on a long-running server and ones on a newly deployed server. Processes on each side were almost same. The only difference was that <code>buffers</code> and <code>cached Mem</code> were high on the long-running one.</p>
<p>After some research, or googling, I concluded that it was not a problem. Most of <code>buffers</code> and <code>cached Mem</code> are given up when application processes claim more memory.</p>
<p>Actually <code>free -m</code> command provides a row for <code>used</code> and <code>free</code> taking buffers and cached into consideration.</p>
<pre><code class="hljs undefined">$ free -m
             total  used  free  shared  buffers cached
Mem:          3950   285  3665     183       12    188
-/+ buffers/cache:    84  3866
Swap:         1896     0  1896</code></pre><p>So, what are they actually? According to <a href="http://man7.org/linux/man-pages/man5/proc.5.html">the manual of <code>/proc/meminfo</code></a>, which is a pseudo file and the data source of <code>free</code>, <code>top</code> and friends:</p>
<pre><code class="hljs undefined">Buffers %lu
       Relatively temporary storage for raw disk blocks that
       shouldn't get tremendously large (20MB or so).

Cached %lu
       In-memory cache for files read from the disk (the page
       cache).  Doesn't include SwapCached.</code></pre><p>I am still not sure what exactly <code>Buffers</code> contains, but it contains metadata of files, etc. and it&#39;s relatively trivial in size. <code>Cached</code> contains cached file contents, which are called page cache. OS keeps page cache while RAM has enough free space. That was why the memory usage was increasing even when processes were not leaking memory.</p>
<p>If you are interested, <a href="https://www.quora.com/What-is-the-difference-between-Buffers-and-Cached-columns-in-proc-meminfo-output">What is the difference between Buffers and Cached columns in /proc/meminfo output?</a> on Quora has more details about <code>Buffers</code> and <code>Cached</code>.</p>
<h2 id="memavailable">MemAvailable</h2>
<p>So, should we use <code>free + buffers + cached</code>? <code>/proc/meminfo</code> has an even better metric called <code>MemAvailable</code>.</p>
<pre><code class="hljs undefined">MemAvailable %lu (since Linux 3.14)
       An estimate of how much memory is available for
       starting new applications, without swapping.</code></pre><pre><code class="hljs undefined">$ cat /proc/meminfo
MemTotal:        4045572 kB
MemFree:         3753648 kB
MemAvailable:    3684028 kB
Buffers:           13048 kB
Cached:           193336 kB
...</code></pre><p>Its background is explained well in <a href="https://github.com/torvalds/linux/commit/34e431b0ae398fc54ea69ff85ec700722c9da773">the commit in Linux Kernel</a>, but essentially it excludes non-freeable page cache and includes reclaimable slab memory. <a href="https://github.com/torvalds/linux/blob/v4.12-rc2/mm/page_alloc.c#L4341-L4382">The current implementation in Linux v4.12-rc2</a> still looks almost same.</p>
<p>Some implementation of <code>free -m</code> have <code>available</code> column. For example, on Boot2Docker:</p>
<pre><code class="hljs undefined">$ free -m
       total  used  free  shared  buff/cache  available
Mem:    3950    59  3665     183         226       3597
Swap:   1896     0  1896</code></pre><p>It is also <a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/mon-scripts.html">available on AWS CloudWatch metrics</a> via <code>--mem-avail</code> flag.</p>
<h2 id="some-background-about-docker">Some background about Docker</h2>
<p>My another question was &quot;Are those metrics same in Docker?&quot;. Before diving into this question, let&#39;s check how docker works.</p>
<p>According to <a href="https://docs.docker.com/engine/docker-overview/#the-underlying-technology">Docker Overview: The Underlying Technology</a>, processes in a Docker container directly run in their host OS without any virtualization, but they are isolated from the host OS and other containers in effect thanks to these Linux kernel features:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Linux_namespaces">namespaces</a>: Isolate PIDs, hostnames, user IDs, network accesses, IPC, etc.</li>
<li><a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a>: Limit resource usage</li>
<li><a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a>: Isolate file system</li>
</ul>
<p>Because of the namespaces, <code>ps</code> command lists processes of Docker containers in addition to other processes in the host OS, while it cannot list processes of host OS or other containers in a docker container.</p>
<p><a href="https://docs.docker.com/engine/admin/resource_constraints/#memory">By default, Docker containers have no resource constraints</a>. So, if you run one container in a host and don&#39;t limit resource usage of the container, and this is my case, the container&#39;s &quot;free memory&quot; is same as the host OS&#39;s &quot;free memory&quot;.</p>
<h2 id="memory-metrics-on-docker-container">Memory Metrics on Docker Container</h2>
<p>If you want to monitor a Docker container&#39;s memory usage from outside of the container, it&#39;s easy. You can use <code>docker stats</code>.</p>
<pre><code class="hljs undefined">$ docker stats
CONTAINER     CPU %  MEM USAGE / LIMIT  MEM %  NET I/O     BLOCK I/O  PIDS
fc015f31d9d1  0.00%  220KiB / 3.858GiB  0.01%  1.3kB / 0B  0B / 0B    2</code></pre><p>But if you want to get the memory usage in the container or get more detailed metrics, it gets complicated. <a href="https://fabiokung.com/2014/03/13/memory-inside-linux-containers/">Memory inside Linux containers</a> describes the difficulties in details.</p>
<p><code>/proc/meminfo</code> and <code>sysinfo</code>, which is used by <code>os.totalmem()</code> and <code>os.freemem()</code> of Node.js, are not isolated, you get metrics of host OS if you use normal utilities like <code>top</code> and <code>free</code> in a Docker container.</p>
<p>To get metrics specific to your Docker container, <a href="https://docs.docker.com/engine/admin/runmetrics/">you can check pseudo files in <code>/sys/fs/cgroup/memory/</code></a>. They are not standardized according to <a href="https://fabiokung.com/2014/03/13/memory-inside-linux-containers/">Memory inside Linux containers</a> though.</p>
<pre><code class="hljs undefined">$ cat /sys/fs/cgroup/memory/memory.usage_in_bytes
303104
$ cat /sys/fs/cgroup/memory/memory.limit_in_bytes
9223372036854771712</code></pre><p><code>memory.limit_in_bytes</code> returns a very big number if there is no limit. In that case, you can find the host OS&#39;s total memory with <code>/proc/meminfo</code> or commands that use it.</p>
<h2 id="conclusion">Conclusion</h2>
<p>It was a longer journey than I initially thought. My takeaways are:</p>
<ul>
<li>Available Memory &gt; Free Memory</li>
<li>Use <code>MemAvailable</code> if available (pun intended)</li>
<li>Processes in a Docker container run directly in host OS</li>
<li>Understand what you are measuring exactly, especially in a Docker container</li>
</ul>
</div></div></div><div class="comments"><div id="disqus_thread"></div><noscript>Please enable JavaScript to view the<a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript></div></div></div><footer class="footer">Â© <!-- -->Shuhei Kagawa</footer></div></div>
        <script><!--
          window.__PRELOADED_PROPS__ = {"site":{"title":"Shuhei Kagawa","author":"Shuhei Kagawa","perPage":3,"newPageExtension":"markdown","blogDir":"blog","sourceDir":"source","layoutDir":"_layouts","postDir":"_posts","cssFiles":["node_modules/highlight.js/styles/monokai-sublime.css","source/_css/style.css"]},"post":{"layout":"post","title":"Getting Memory Usage in Linux and Docker","date":"2017-05-28 16:28","comments":true,"categories":["Linux","Docker"],"url":"/blog/2017/05/27/memory-usage/","content":"<p>Recently I started monitoring a Node.js app that we have been developing at work. After a while, I found that its memory usage % was growing slowly, like 20% in 3 days. The memory usage was measured in the following Node.js code.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> os = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'os'</span>);\n\n<span class=\"hljs-keyword\">const</span> total = os.totalmem();\n<span class=\"hljs-keyword\">const</span> free = os.freemem();\n<span class=\"hljs-keyword\">const</span> usage = (free - total) / total * <span class=\"hljs-number\">100</span>;</code></pre><p>So, they are basically from OS, which was <a href=\"https://alpinelinux.org/\">Alpine Linux</a> on Docker in this case. Luckily I also had memory usages of application processes recorded, but they were not increasing. Then why is the OS memory usage increasing?</p>\n<h2 id=\"buffers-and-cached-memory\">Buffers and Cached Memory</h2>\n<p>I used <code>top</code> command with <code>Shift+m</code> (sort by memory usage) and compared processes on a long-running server and ones on a newly deployed server. Processes on each side were almost same. The only difference was that <code>buffers</code> and <code>cached Mem</code> were high on the long-running one.</p>\n<p>After some research, or googling, I concluded that it was not a problem. Most of <code>buffers</code> and <code>cached Mem</code> are given up when application processes claim more memory.</p>\n<p>Actually <code>free -m</code> command provides a row for <code>used</code> and <code>free</code> taking buffers and cached into consideration.</p>\n<pre><code class=\"hljs undefined\">$ free -m\n             total  used  free  shared  buffers cached\nMem:          3950   285  3665     183       12    188\n-/+ buffers/cache:    84  3866\nSwap:         1896     0  1896</code></pre><p>So, what are they actually? According to <a href=\"http://man7.org/linux/man-pages/man5/proc.5.html\">the manual of <code>/proc/meminfo</code></a>, which is a pseudo file and the data source of <code>free</code>, <code>top</code> and friends:</p>\n<pre><code class=\"hljs undefined\">Buffers %lu\n       Relatively temporary storage for raw disk blocks that\n       shouldn't get tremendously large (20MB or so).\n\nCached %lu\n       In-memory cache for files read from the disk (the page\n       cache).  Doesn't include SwapCached.</code></pre><p>I am still not sure what exactly <code>Buffers</code> contains, but it contains metadata of files, etc. and it&#39;s relatively trivial in size. <code>Cached</code> contains cached file contents, which are called page cache. OS keeps page cache while RAM has enough free space. That was why the memory usage was increasing even when processes were not leaking memory.</p>\n<p>If you are interested, <a href=\"https://www.quora.com/What-is-the-difference-between-Buffers-and-Cached-columns-in-proc-meminfo-output\">What is the difference between Buffers and Cached columns in /proc/meminfo output?</a> on Quora has more details about <code>Buffers</code> and <code>Cached</code>.</p>\n<h2 id=\"memavailable\">MemAvailable</h2>\n<p>So, should we use <code>free + buffers + cached</code>? <code>/proc/meminfo</code> has an even better metric called <code>MemAvailable</code>.</p>\n<pre><code class=\"hljs undefined\">MemAvailable %lu (since Linux 3.14)\n       An estimate of how much memory is available for\n       starting new applications, without swapping.</code></pre><pre><code class=\"hljs undefined\">$ cat /proc/meminfo\nMemTotal:        4045572 kB\nMemFree:         3753648 kB\nMemAvailable:    3684028 kB\nBuffers:           13048 kB\nCached:           193336 kB\n...</code></pre><p>Its background is explained well in <a href=\"https://github.com/torvalds/linux/commit/34e431b0ae398fc54ea69ff85ec700722c9da773\">the commit in Linux Kernel</a>, but essentially it excludes non-freeable page cache and includes reclaimable slab memory. <a href=\"https://github.com/torvalds/linux/blob/v4.12-rc2/mm/page_alloc.c#L4341-L4382\">The current implementation in Linux v4.12-rc2</a> still looks almost same.</p>\n<p>Some implementation of <code>free -m</code> have <code>available</code> column. For example, on Boot2Docker:</p>\n<pre><code class=\"hljs undefined\">$ free -m\n       total  used  free  shared  buff/cache  available\nMem:    3950    59  3665     183         226       3597\nSwap:   1896     0  1896</code></pre><p>It is also <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/mon-scripts.html\">available on AWS CloudWatch metrics</a> via <code>--mem-avail</code> flag.</p>\n<h2 id=\"some-background-about-docker\">Some background about Docker</h2>\n<p>My another question was &quot;Are those metrics same in Docker?&quot;. Before diving into this question, let&#39;s check how docker works.</p>\n<p>According to <a href=\"https://docs.docker.com/engine/docker-overview/#the-underlying-technology\">Docker Overview: The Underlying Technology</a>, processes in a Docker container directly run in their host OS without any virtualization, but they are isolated from the host OS and other containers in effect thanks to these Linux kernel features:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Linux_namespaces\">namespaces</a>: Isolate PIDs, hostnames, user IDs, network accesses, IPC, etc.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cgroups\">cgroups</a>: Limit resource usage</li>\n<li><a href=\"https://en.wikipedia.org/wiki/UnionFS\">UnionFS</a>: Isolate file system</li>\n</ul>\n<p>Because of the namespaces, <code>ps</code> command lists processes of Docker containers in addition to other processes in the host OS, while it cannot list processes of host OS or other containers in a docker container.</p>\n<p><a href=\"https://docs.docker.com/engine/admin/resource_constraints/#memory\">By default, Docker containers have no resource constraints</a>. So, if you run one container in a host and don&#39;t limit resource usage of the container, and this is my case, the container&#39;s &quot;free memory&quot; is same as the host OS&#39;s &quot;free memory&quot;.</p>\n<h2 id=\"memory-metrics-on-docker-container\">Memory Metrics on Docker Container</h2>\n<p>If you want to monitor a Docker container&#39;s memory usage from outside of the container, it&#39;s easy. You can use <code>docker stats</code>.</p>\n<pre><code class=\"hljs undefined\">$ docker stats\nCONTAINER     CPU %  MEM USAGE / LIMIT  MEM %  NET I/O     BLOCK I/O  PIDS\nfc015f31d9d1  0.00%  220KiB / 3.858GiB  0.01%  1.3kB / 0B  0B / 0B    2</code></pre><p>But if you want to get the memory usage in the container or get more detailed metrics, it gets complicated. <a href=\"https://fabiokung.com/2014/03/13/memory-inside-linux-containers/\">Memory inside Linux containers</a> describes the difficulties in details.</p>\n<p><code>/proc/meminfo</code> and <code>sysinfo</code>, which is used by <code>os.totalmem()</code> and <code>os.freemem()</code> of Node.js, are not isolated, you get metrics of host OS if you use normal utilities like <code>top</code> and <code>free</code> in a Docker container.</p>\n<p>To get metrics specific to your Docker container, <a href=\"https://docs.docker.com/engine/admin/runmetrics/\">you can check pseudo files in <code>/sys/fs/cgroup/memory/</code></a>. They are not standardized according to <a href=\"https://fabiokung.com/2014/03/13/memory-inside-linux-containers/\">Memory inside Linux containers</a> though.</p>\n<pre><code class=\"hljs undefined\">$ cat /sys/fs/cgroup/memory/memory.usage_in_bytes\n303104\n$ cat /sys/fs/cgroup/memory/memory.limit_in_bytes\n9223372036854771712</code></pre><p><code>memory.limit_in_bytes</code> returns a very big number if there is no limit. In that case, you can find the host OS&#39;s total memory with <code>/proc/meminfo</code> or commands that use it.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>It was a longer journey than I initially thought. My takeaways are:</p>\n<ul>\n<li>Available Memory &gt; Free Memory</li>\n<li>Use <code>MemAvailable</code> if available (pun intended)</li>\n<li>Processes in a Docker container run directly in host OS</li>\n<li>Understand what you are measuring exactly, especially in a Docker container</li>\n</ul>\n"}};
        --></script>
        <script src="/js/index.js"></script>
      </body>
    </html>