{"site":{"title":"Shuhei Kagawa","author":"Shuhei Kagawa","perPage":3,"newPageExtension":"markdown","blogDir":"blog","sourceDir":"source","layoutDir":"_layouts","postDir":"_posts"},"posts":[{"layout":"post","title":"HTTP request timeouts in JavaScript","date":"2017-05-14 23:31","comments":true,"categories":["JavaScript"],"url":"/blog/2017/05/13/http-request-timeouts-in-javascript/","content":"<p>These days I have been working on a Node.js front-end server that calls back-end APIs and renders HTML with React components. In this microservices setup, I am making sure that the server doesn&#39;t become too slow even when its dependencies have problems. So I need to set timeouts to the API calls so that the server can give up non-essential dependencies quickly and fail fast when essential dependencies are out of order.</p>\n<p>As I started looking at timeout options carefully, I quickly found that there were many different kinds of timeouts even in the very limited field, HTTP request with JavaScript.</p>\n<h2 id=\"node-js-http-https-\">Node.js &quot;http&quot;/&quot;https&quot;</h2>\n<p>Let&#39;s start with the standard library of Node.js. <code>http</code> and <code>https</code> provide <code>request()</code> function, which makes HTTP requests.</p>\n<h3 id=\"timeouts-on-http-request-\">Timeouts on <code>http.request()</code></h3>\n<p><a href=\"http://nodejs.org/api/http.html#http_http_request_options_callback\"><code>http.request()</code></a> takes a <code>timeout</code> option. Its documentation says:</p>\n<blockquote>\n<p><code>timeout</code> <code>&lt;number&gt;</code>: A number specifying the socket timeout in milliseconds. This will set the timeout before the socket is connected.</p>\n</blockquote>\n<p>So what does it actually do? It internally calls <code>net.createConnection()</code> with its <code>timeout</code> option, which eventually calls <code>socket.setTimeout()</code> before the socket starts connecting.</p>\n<p>There is also <a href=\"http://nodejs.org/api/http.html#http_request_settimeout_timeout_callback\"><code>http.ClientRequest.setTimeout()</code></a>. Its documentation says:</p>\n<blockquote>\n<p>Once a socket is assigned to this request and is connected <code>socket.setTimeout()</code> will be called.</p>\n</blockquote>\n<p>So this also calls <a href=\"http://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback\"><code>socket.setTimeout()</code></a>.</p>\n<p>Either of them don&#39;t close the connection when the socket timeouts but only emits a <code>timeout</code> event.</p>\n<p>So, what does <code>socket.setTimeout()</code> do? Let&#39;s check.</p>\n<h3 id=\"net-socket-settimeout-\">net.Socket.setTimeout()</h3>\n<p><a href=\"http://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback\">The documentation</a> says:</p>\n<blockquote>\n<p>Sets the socket to timeout after timeout milliseconds of inactivity on the socket. By default net.Socket do not have a timeout.</p>\n</blockquote>\n<p>OK, but what does &quot;inactivity on the socket&quot; exactly mean? In a happy path, a TCP socket follows the following steps:</p>\n<ol>\n<li>Start connecting</li>\n<li>DNS lookup is done: <code>lookup</code> event (Doesn&#39;t happen in HTTP Keep-Alive)</li>\n<li>Connection is made: <code>connect</code> event (Doesn&#39;t happen in HTTP Keep-Alive)</li>\n<li>Read data or write data</li>\n</ol>\n<p>When you call <code>socket.setTimeout()</code>, a timeout timer is created and restarted before connecting, after <code>lookup</code>, after <code>connect</code> and each data read &amp; write. So the <code>timeout</code> event is emitted on one of the following cases:</p>\n<ul>\n<li>DNS lookup doesn&#39;t finish in the given timeout</li>\n<li>TCP connection is not made in the given timeout after DNS lookup</li>\n<li>No data read or write in the given timeout after connection, previous data read or write</li>\n</ul>\n<p>This might be a bit counter-intuitive. Let&#39;s say you called <code>socket.setTimeout(300)</code> to set the timeout as 300 ms, and it took 100 ms for DNS lookup, 100 ms for making a connection with a remote server, 200 ms for the remote server to send response headers, 50 ms for transferring the first half of the response body and another 50 ms for the rest. While the entire request &amp; response took more than 500 ms, <code>timeout</code> event is not emitted at all.</p>\n<p>Because the timeout timer is restarted in each step, timeout happens only when a step is not completed in the given time.</p>\n<p>Then what happens if timeouts happen in all of the steps? As far as I tried, <code>timeout</code> event is triggered only once.</p>\n<p>Another concern is HTTP Keep-Alive, which reuses a socket for multiple HTTP requests. What happens if you set timeout for a socket and the socket is reused for another HTTP request? Never mind. <code>timeout</code> set in a HTTP request does not affect subsequent HTTP requests because <a href=\"https://github.com/nodejs/node/blob/v7.10.0/lib/_http_client.js#L546\">the timeout is cleaned up when it&#39;s kept alive</a>.</p>\n<h3 id=\"http-keep-alive-tcp-keep-alive\">HTTP Keep-Alive &amp; TCP Keep-Alive</h3>\n<p>This is not directly related to timeout, but I found Keep-Alive options in <code>http</code>/<code>https</code> are a bit confusing. They mix HTTP Keep-Alive and TCP Keep-Alive, which are completely different things but coincidentally have the same name. For example, the options of <a href=\"http://nodejs.org/api/http.html#http_new_agent_options\"><code>http.Agent</code> constructor</a> has <code>keepAlive</code> for HTTP Keep-Alive and <code>keepAliveMsecs</code> for TCP Keep-Alive.</p>\n<p>So, how are they different?</p>\n<ul>\n<li>HTTP Keep-Alive reuses a TCP connection for multiple HTTP requests. It saves the TCP connection overhead such as DNS lookup and TCP slow start.</li>\n<li>TCP Keep-Alive closes invalid connections, and it is normally handled by OS.</li>\n</ul>\n<h3 id=\"so-\">So?</h3>\n<p><code>http</code>/<code>https</code> use <code>socket.setTimeout()</code> whose timer is restarted in stages of socket lifecycle. It doesn&#39;t ensure a timeout for the overall request &amp; response. If you want to make sure that a request completes in a specific time or fails, you need to prepare your own timeout solution.</p>\n<h2 id=\"third-party-modules\">Third-party modules</h2>\n<h3 id=\"-request-module\">&quot;request&quot; module</h3>\n<p><a href=\"https://github.com/request/request\">request</a> is a very popular HTTP request library that supports many convenient features on top of <code>http</code>/<code>https</code> module. Its README says:</p>\n<blockquote>\n<p><code>timeout</code> - Integer containing the number of milliseconds to wait for a server to send response headers (and start the response body) before aborting the request.</p>\n</blockquote>\n<p>However, as far as I checked the implementation, <code>timeout</code> is not applied to the timing of response headers as of v2.81.1.</p>\n<p>Currently this module emits the two types of timeout errors:</p>\n<ul>\n<li><code>ESOCKETTIMEDOUT</code>: Emitted from <code>http.ClientRequest.setTimeout()</code> described above, which uses <code>socket.setTimeout()</code>.</li>\n<li><code>ETIMEDOUT</code>: Emitted when a connection is not established in the given timeout. It was applied to the timing of response headers before v2.76.0.</li>\n</ul>\n<p>There is <a href=\"https://github.com/request/request/issues/2535\">a GitHub issue</a> for it, but I&#39;m not sure if it&#39;s intended and the README is outdated, or it&#39;s a bug.</p>\n<p>By the way, <code>request</code> provides a useful timing measurement feature that you can enable with <code>time</code> option. It will help you to define a proper timeout value.</p>\n<h3 id=\"-axios-module\">&quot;axios&quot; module</h3>\n<p><a href=\"https://github.com/mzabriskie/axios\"><code>axios</code></a> is another popular library that uses <code>Promise</code>. Like <code>request</code> module&#39;s README, its <code>timeout</code> option timeouts if the response status code and headers don&#39;t arrive in the given timeout.</p>\n<h2 id=\"browser-apis\">Browser APIs</h2>\n<p>While my initial interest was server-side HTTP requests, I become curious about browser APIs as I was investigating Node.js options.</p>\n<h3 id=\"xmlhttprequest\">XMLHttpRequest</h3>\n<p><a href=\"http://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout\"><code>XMLHttpRequest.timeout</code></a> aborts a request after the given timeout and calls <code>ontimeout</code> event listeners. The documentation does not say about the exact timing, but I guess that it is until <code>readyState === 4</code>, which means that the entire response body has arrived.</p>\n<h3 id=\"fetch-\">fetch()</h3>\n<p>As far as I read <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\"><code>fetch()</code>&#39;s documentation on MDN</a>, it does not have any way to specify timeout. So we need to handle by ourselves. We can do that easily using <a href=\"http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\"><code>Promise.race()</code></a>.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">withTimeout</span>(<span class=\"hljs-params\">msecs, promise</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> timeout = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'timeout'</span>));\n    }, msecs);\n  });\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.race([timeout, promise]);\n}\n\nwithTimeout(<span class=\"hljs-number\">1000</span>, fetch(<span class=\"hljs-string\">'https://foo.com/bar/'</span>))\n  .then(doSomething)\n  .catch(handleError);</code></pre><p>This kind of external approach works with any HTTP client and timeouts for the overall request and response. However, it does not abort the underlying HTTP request while preceding timeouts actually abort HTTP requests and save some resources.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Most of the HTTP request APIs in JavaScript don&#39;t offer timeout mechanism for the overall request and response. If you want to limit the maximum processing time for your piece of code, you have to prepare your own timeout solution. However, if your solution relies on high-level abstraction like <code>Promise</code> and cannot abort underlying TCP socket and HTTP request when timeout, it is nice to use the exiting low-level timeout mechanisms like <code>socket.setTimeout()</code> together to save some resources.</p>\n"},{"layout":"post","title":"How to export CommonJS and ES Module","date":"2017-01-05 22:11","comments":true,"categories":["JavaScript"],"url":"/blog/2017/01/05/how-to-export-commonjs-and-es-module/","content":"<p>After <a href=\"/blog/2017/01/05/main-jsnext-main-and-module/\">my previous post about jsnext:main and module</a>, there came another issue.</p>\n<ul>\n<li><a href=\"https://github.com/shuhei/material-colors/issues/16\">colors.es2015.js and colors.js have different APIs · Issue #16 · shuhei/material-colors</a>.</li>\n</ul>\n<p>Here is the twists and turns that I wandered to solve the problem.</p>\n<h2 id=\"exports\">Exports</h2>\n<p>The code of <code>material-colors</code> looked like the following.</p>\n<p><code>colors.js</code> specified in <code>main</code> (CommonJS version)</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">red</span>: { <span class=\"hljs-comment\">/* ... */</span> },\n  <span class=\"hljs-attr\">blue</span>: { <span class=\"hljs-comment\">/* ... */</span> }\n};</code></pre><p><code>colors.es2015.js</code> specified in <code>jsnext:main/module</code> (ES Module version)</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> red = { <span class=\"hljs-comment\">/* ... */</span> };\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> blue = { <span class=\"hljs-comment\">/* ... */</span> };</code></pre><p>Then the ES Module file can get benefit of tree shaking if it&#39;s imported by named imports.</p>\n<h2 id=\"problem-of-having-only-named-exports\">Problem of having only named exports</h2>\n<p>The <code>colors.es2015.js</code> broke <code>react-color</code> when built with Webpack 2 because it was doing default import but <code>colors.es2015.js</code> didn&#39;t have default export.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> material <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'material-colors'</span>;\n<span class=\"hljs-built_in\">console</span>.log(material.red);</code></pre><p>So <a href=\"https://github.com/echenley\">@echenley</a> suggested to change it to a wildcard import.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> material <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'material-colors'</span>;\n<span class=\"hljs-built_in\">console</span>.log(material.red);</code></pre><p>It worked well, but I removed <code>jsnext:main</code> and <code>module</code> because other libraries with default import may break on Webpack 2 and <code>material-colors</code> is already tiny without tree shaking anyway.</p>\n<h2 id=\"have-a-default-export\">Have a default export</h2>\n<p>After a while, I came up with a better solution to have a default export in addition to named exports. Then it will work well with tree shaking and won&#39;t break default import. Pretty obvious after coming up.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> red = { <span class=\"hljs-comment\">/* ... */</span> };\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> blue = { <span class=\"hljs-comment\">/* ... */</span> };\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">red</span>: red,\n  <span class=\"hljs-attr\">blue</span>: blue\n};</code></pre><h2 id=\"so-\">So?</h2>\n<p>To keep maximum compatibility for CommonJS and ES Module:</p>\n<ul>\n<li>If your CommonJS module exports only one thing, like encouraged in the npm world, export it as a default export.</li>\n<li>If your CommonJS module exports multiple things, which essentially exports an object with them as properties, export named exports. In addition to it, it&#39;s safer to have a default export just in case for the problem described above.</li>\n</ul>\n"},{"layout":"post","title":"main, jsnext:main and module","date":"2017-01-05 00:00","comments":true,"categories":["JavaScript"],"url":"/blog/2017/01/05/main-jsnext-main-and-module/","content":"<p>Node module&#39;s <code>package.json</code> has <code>main</code> property. It&#39;s the entry point of a package, which is exported when a client <code>require</code>s the package.</p>\n<p>Recently, I got <a href=\"https://github.com/shuhei/material-colors/issues/13\">an issue</a> on one of my popular GitHub repos, <code>material-colors</code>. It claimed that &quot;colors.es2015.js const not supported in older browser (Safari 9)&quot;, which looked pretty obvious to me. ES2015 is a new spec. Why do older browsers support it?</p>\n<p>I totally forgot about it at the time, but <a href=\"https://github.com/shuhei/material-colors/pull/10\">the <code>colors.es2015.js</code> was exposed as the npm package&#39;s <code>jsnext:main</code></a>. And to my surprise, it turned out that <strong><code>jsnext:main</code> shouldn&#39;t have <em>jsnext</em> or ES2015+ features</strong> like <code>const</code>, arrow function and <code>class</code>. What a contradiction!</p>\n<h2 id=\"jsnext-main\">jsnext:main</h2>\n<p>Module bundlers that utilizes tree shaking to reduce bundle size, like Rollup and Webpack 2, require packages to expose ES Modules with <code>import</code> and <code>export</code>. So they invented a non-standard property called <code>jsnext:main</code>.</p>\n<p>However, it had a problem. If the file specified <code>jsnext:main</code> contains ES2015+ features, it won&#39;t run without transpilation on browsers that don&#39;t support those features. But normally people don&#39;t transpile packages in <code>node_modules</code>, and many issues were created on GitHub. To solve the problem, people concluded that <code>jsnext:main</code> shouldn&#39;t have ES2015+ features other than <code>import</code> and <code>export</code>. What an irony.</p>\n<h2 id=\"module\">module</h2>\n<p>Now the name <code>jsnext:main</code> is too confusing. I was confused at least. People discussed for a better name, and <a href=\"https://github.com/rollup/rollup/wiki/pkg.module\"><code>module</code></a> came out that <a href=\"https://github.com/rollup/rollup/wiki/jsnext:main\">supersedes <code>jsnext:main</code></a>. And <a href=\"https://nodesource.com/blog/es-modules-and-node-js-hard-choices/\">it might be standardized</a>.</p>\n<h2 id=\"so-\">So?</h2>\n<p>I looked into a couple of popular repos, and they had both of <code>jsnext:main</code> and <code>module</code> in addition to <code>main</code>.</p>\n<ul>\n<li><a href=\"https://github.com/reactjs/redux/blob/master/package.json\">redux</a></li>\n<li><a href=\"https://github.com/mrdoob/three.js/blob/dev/package.json\">three.js</a></li>\n</ul>\n<p>At this time, it seems to be a good idea to have both of them if you want to support tree shaking. If you don&#39;t, just go with only the plain old <code>main</code>.</p>\n"}],"title":"Shuhei Kagawa","nextPage":"/blog/pages/2/"}