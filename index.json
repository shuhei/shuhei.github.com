{"site":{"title":"Shuhei Kagawa","author":"Shuhei Kagawa","perPage":3,"newPageExtension":"markdown","blogDir":"blog","sourceDir":"source","layoutDir":"_layouts","postDir":"_posts","cssFiles":["node_modules/highlight.js/styles/monokai-sublime.css","source/_css/style.css"]},"posts":[{"layout":"post","title":"Getting Memory Usage in Linux and Docker","date":"2017-05-28 16:28","comments":true,"categories":["Linux","Docker"],"url":"/blog/2017/05/27/memory-usage/","content":"<p>Recently I started monitoring a Node.js app that we have been developing at work. After a while, I found that its memory usage % was growing slowly, like 20% in 3 days. The memory usage was measured in the following Node.js code.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> os = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'os'</span>);\n\n<span class=\"hljs-keyword\">const</span> total = os.totalmem();\n<span class=\"hljs-keyword\">const</span> free = os.freemem();\n<span class=\"hljs-keyword\">const</span> usage = (free - total) / total * <span class=\"hljs-number\">100</span>;</code></pre><p>So, they are basically from OS, which was <a href=\"https://alpinelinux.org/\">Alpine Linux</a> on Docker in this case. Luckily I also had memory usages of application processes recorded, but they were not increasing. Then why is the OS memory usage increasing?</p>\n<h2 id=\"buffers-and-cached-memory\">Buffers and Cached Memory</h2>\n<p>I used <code>top</code> command with <code>Shift+m</code> (sort by memory usage) and compared processes on a long-running server and ones on a newly deployed server. Processes on each side were almost same. The only difference was that <code>buffers</code> and <code>cached Mem</code> were high on the long-running one.</p>\n<p>After some research, or googling, I concluded that it was not a problem. Most of <code>buffers</code> and <code>cached Mem</code> are given up when application processes claim more memory.</p>\n<p>Actually <code>free -m</code> command provides a row for <code>used</code> and <code>free</code> taking buffers and cached into consideration.</p>\n<pre><code class=\"hljs undefined\">$ free -m\n             total  used  free  shared  buffers cached\nMem:          3950   285  3665     183       12    188\n-/+ buffers/cache:    84  3866\nSwap:         1896     0  1896</code></pre><p>So, what are they actually? According to <a href=\"http://man7.org/linux/man-pages/man5/proc.5.html\">the manual of <code>/proc/meminfo</code></a>, which is a pseudo file and the data source of <code>free</code>, <code>top</code> and friends:</p>\n<pre><code class=\"hljs undefined\">Buffers %lu\n       Relatively temporary storage for raw disk blocks that\n       shouldn't get tremendously large (20MB or so).\n\nCached %lu\n       In-memory cache for files read from the disk (the page\n       cache).  Doesn't include SwapCached.</code></pre><p>I am still not sure what exactly <code>Buffers</code> contains, but it contains metadata of files, etc. and it&#39;s relatively trivial in size. <code>Cached</code> contains cached file contents, which are called page cache. OS keeps page cache while RAM has enough free space. That was why the memory usage was increasing even when processes were not leaking memory.</p>\n<p>If you are interested, <a href=\"https://www.quora.com/What-is-the-difference-between-Buffers-and-Cached-columns-in-proc-meminfo-output\">What is the difference between Buffers and Cached columns in /proc/meminfo output?</a> on Quora has more details about <code>Buffers</code> and <code>Cached</code>.</p>\n<h2 id=\"memavailable\">MemAvailable</h2>\n<p>So, should we use <code>free + buffers + cached</code>? <code>/proc/meminfo</code> has an even better metric called <code>MemAvailable</code>.</p>\n<pre><code class=\"hljs undefined\">MemAvailable %lu (since Linux 3.14)\n       An estimate of how much memory is available for\n       starting new applications, without swapping.</code></pre><pre><code class=\"hljs undefined\">$ cat /proc/meminfo\nMemTotal:        4045572 kB\nMemFree:         3753648 kB\nMemAvailable:    3684028 kB\nBuffers:           13048 kB\nCached:           193336 kB\n...</code></pre><p>Its background is explained well in <a href=\"https://github.com/torvalds/linux/commit/34e431b0ae398fc54ea69ff85ec700722c9da773\">the commit in Linux Kernel</a>, but essentially it excludes non-freeable page cache and includes reclaimable slab memory. <a href=\"https://github.com/torvalds/linux/blob/v4.12-rc2/mm/page_alloc.c#L4341-L4382\">The current implementation in Linux v4.12-rc2</a> still looks almost same.</p>\n<p>Some implementation of <code>free -m</code> have <code>available</code> column. For example, on Boot2Docker:</p>\n<pre><code class=\"hljs undefined\">$ free -m\n       total  used  free  shared  buff/cache  available\nMem:    3950    59  3665     183         226       3597\nSwap:   1896     0  1896</code></pre><p>It is also <a href=\"http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/mon-scripts.html\">available on AWS CloudWatch metrics</a> via <code>--mem-avail</code> flag.</p>\n<h2 id=\"some-background-about-docker\">Some background about Docker</h2>\n<p>My another question was &quot;Are those metrics same in Docker?&quot;. Before diving into this question, let&#39;s check how docker works.</p>\n<p>According to <a href=\"https://docs.docker.com/engine/docker-overview/#the-underlying-technology\">Docker Overview: The Underlying Technology</a>, processes in a Docker container directly run in their host OS without any virtualization, but they are isolated from the host OS and other containers in effect thanks to these Linux kernel features:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Linux_namespaces\">namespaces</a>: Isolate PIDs, hostnames, user IDs, network accesses, IPC, etc.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Cgroups\">cgroups</a>: Limit resource usage</li>\n<li><a href=\"https://en.wikipedia.org/wiki/UnionFS\">UnionFS</a>: Isolate file system</li>\n</ul>\n<p>Because of the namespaces, <code>ps</code> command lists processes of Docker containers in addition to other processes in the host OS, while it cannot list processes of host OS or other containers in a docker container.</p>\n<p><a href=\"https://docs.docker.com/engine/admin/resource_constraints/#memory\">By default, Docker containers have no resource constraints</a>. So, if you run one container in a host and don&#39;t limit resource usage of the container, and this is my case, the container&#39;s &quot;free memory&quot; is same as the host OS&#39;s &quot;free memory&quot;.</p>\n<h2 id=\"memory-metrics-on-docker-container\">Memory Metrics on Docker Container</h2>\n<p>If you want to monitor a Docker container&#39;s memory usage from outside of the container, it&#39;s easy. You can use <code>docker stats</code>.</p>\n<pre><code class=\"hljs undefined\">$ docker stats\nCONTAINER     CPU %  MEM USAGE / LIMIT  MEM %  NET I/O     BLOCK I/O  PIDS\nfc015f31d9d1  0.00%  220KiB / 3.858GiB  0.01%  1.3kB / 0B  0B / 0B    2</code></pre><p>But if you want to get the memory usage in the container or get more detailed metrics, it gets complicated. <a href=\"https://fabiokung.com/2014/03/13/memory-inside-linux-containers/\">Memory inside Linux containers</a> describes the difficulties in details.</p>\n<p><code>/proc/meminfo</code> and <code>sysinfo</code>, which is used by <code>os.totalmem()</code> and <code>os.freemem()</code> of Node.js, are not isolated, you get metrics of host OS if you use normal utilities like <code>top</code> and <code>free</code> in a Docker container.</p>\n<p>To get metrics specific to your Docker container, <a href=\"https://docs.docker.com/engine/admin/runmetrics/\">you can check pseudo files in <code>/sys/fs/cgroup/memory/</code></a>. They are not standardized according to <a href=\"https://fabiokung.com/2014/03/13/memory-inside-linux-containers/\">Memory inside Linux containers</a> though.</p>\n<pre><code class=\"hljs undefined\">$ cat /sys/fs/cgroup/memory/memory.usage_in_bytes\n303104\n$ cat /sys/fs/cgroup/memory/memory.limit_in_bytes\n9223372036854771712</code></pre><p><code>memory.limit_in_bytes</code> returns a very big number if there is no limit. In that case, you can find the host OS&#39;s total memory with <code>/proc/meminfo</code> or commands that use it.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>It was a longer journey than I initially thought. My takeaways are:</p>\n<ul>\n<li>Available Memory &gt; Free Memory</li>\n<li>Use <code>MemAvailable</code> if available (pun intended)</li>\n<li>Processes in a Docker container run directly in host OS</li>\n<li>Understand what you are measuring exactly, especially in a Docker container</li>\n</ul>\n"},{"layout":"post","title":"HTTP request timeouts in JavaScript","date":"2017-05-14 23:31","comments":true,"categories":["JavaScript"],"url":"/blog/2017/05/13/http-request-timeouts-in-javascript/","content":"<p>These days I have been working on a Node.js front-end server that calls back-end APIs and renders HTML with React components. In this microservices setup, I am making sure that the server doesn&#39;t become too slow even when its dependencies have problems. So I need to set timeouts to the API calls so that the server can give up non-essential dependencies quickly and fail fast when essential dependencies are out of order.</p>\n<p>As I started looking at timeout options carefully, I quickly found that there were many different kinds of timeouts even in the very limited field, HTTP request with JavaScript.</p>\n<h2 id=\"node-js-http-https-\">Node.js &quot;http&quot;/&quot;https&quot;</h2>\n<p>Let&#39;s start with the standard library of Node.js. <code>http</code> and <code>https</code> provide <code>request()</code> function, which makes HTTP requests.</p>\n<h3 id=\"timeouts-on-http-request-\">Timeouts on <code>http.request()</code></h3>\n<p><a href=\"http://nodejs.org/api/http.html#http_http_request_options_callback\"><code>http.request()</code></a> takes a <code>timeout</code> option. Its documentation says:</p>\n<blockquote>\n<p><code>timeout</code> <code>&lt;number&gt;</code>: A number specifying the socket timeout in milliseconds. This will set the timeout before the socket is connected.</p>\n</blockquote>\n<p>So what does it actually do? It internally calls <code>net.createConnection()</code> with its <code>timeout</code> option, which eventually calls <code>socket.setTimeout()</code> before the socket starts connecting.</p>\n<p>There is also <a href=\"http://nodejs.org/api/http.html#http_request_settimeout_timeout_callback\"><code>http.ClientRequest.setTimeout()</code></a>. Its documentation says:</p>\n<blockquote>\n<p>Once a socket is assigned to this request and is connected <code>socket.setTimeout()</code> will be called.</p>\n</blockquote>\n<p>So this also calls <a href=\"http://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback\"><code>socket.setTimeout()</code></a>.</p>\n<p>Either of them doesn&#39;t close the connection when the socket timeouts but only emits a <code>timeout</code> event.</p>\n<p>So, what does <code>socket.setTimeout()</code> do? Let&#39;s check.</p>\n<h3 id=\"net-socket-settimeout-\">net.Socket.setTimeout()</h3>\n<p><a href=\"http://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback\">The documentation</a> says:</p>\n<blockquote>\n<p>Sets the socket to timeout after timeout milliseconds of inactivity on the socket. By default <code>net.Socket</code> does not have a timeout.</p>\n</blockquote>\n<p>OK, but what does &quot;inactivity on the socket&quot; exactly mean? In a happy path, a TCP socket follows the following steps:</p>\n<ol>\n<li>Start connecting</li>\n<li>DNS lookup is done: <code>lookup</code> event (Doesn&#39;t happen in HTTP Keep-Alive)</li>\n<li>Connection is made: <code>connect</code> event (Doesn&#39;t happen in HTTP Keep-Alive)</li>\n<li>Read data or write data</li>\n</ol>\n<p>When you call <code>socket.setTimeout()</code>, a timeout timer is created and restarted before connecting, after <code>lookup</code>, after <code>connect</code> and each data read &amp; write. So the <code>timeout</code> event is emitted on one of the following cases:</p>\n<ul>\n<li>DNS lookup doesn&#39;t finish in the given timeout</li>\n<li>TCP connection is not made in the given timeout after DNS lookup</li>\n<li>No data read or write in the given timeout after connection, previous data read or write</li>\n</ul>\n<p>This might be a bit counter-intuitive. Let&#39;s say you called <code>socket.setTimeout(300)</code> to set the timeout as 300 ms, and it took 100 ms for DNS lookup, 100 ms for making a connection with a remote server, 200 ms for the remote server to send response headers, 50 ms for transferring the first half of the response body and another 50 ms for the rest. While the entire request &amp; response took more than 500 ms, <code>timeout</code> event is not emitted at all.</p>\n<p>Because the timeout timer is restarted in each step, timeout happens only when a step is not completed in the given time.</p>\n<p>Then what happens if timeouts happen in all of the steps? As far as I tried, <code>timeout</code> event is triggered only once.</p>\n<p>Another concern is HTTP Keep-Alive, which reuses a socket for multiple HTTP requests. What happens if you set a timeout for a socket and the socket is reused for another HTTP request? Never mind. <code>timeout</code> set in an HTTP request does not affect subsequent HTTP requests because <a href=\"https://github.com/nodejs/node/blob/v7.10.0/lib/_http_client.js#L546\">the timeout is cleaned up when it&#39;s kept alive</a>.</p>\n<h3 id=\"http-keep-alive-tcp-keep-alive\">HTTP Keep-Alive &amp; TCP Keep-Alive</h3>\n<p>This is not directly related to timeout, but I found Keep-Alive options in <code>http</code>/<code>https</code> are a bit confusing. They mix HTTP Keep-Alive and TCP Keep-Alive, which are completely different things but coincidentally have the same name. For example, the options of <a href=\"http://nodejs.org/api/http.html#http_new_agent_options\"><code>http.Agent</code> constructor</a> has <code>keepAlive</code> for HTTP Keep-Alive and <code>keepAliveMsecs</code> for TCP Keep-Alive.</p>\n<p>So, how are they different?</p>\n<ul>\n<li>HTTP Keep-Alive reuses a TCP connection for multiple HTTP requests. It saves the TCP connection overhead such as DNS lookup and TCP slow start.</li>\n<li>TCP Keep-Alive closes invalid connections, and it is normally handled by OS.</li>\n</ul>\n<h3 id=\"so-\">So?</h3>\n<p><code>http</code>/<code>https</code> use <code>socket.setTimeout()</code> whose timer is restarted in stages of socket lifecycle. It doesn&#39;t ensure a timeout for the overall request &amp; response. If you want to make sure that a request completes in a specific time or fails, you need to prepare your own timeout solution.</p>\n<h2 id=\"third-party-modules\">Third-party modules</h2>\n<h3 id=\"-request-module\">&quot;request&quot; module</h3>\n<p><a href=\"https://github.com/request/request\">request</a> is a very popular HTTP request library that supports many convenient features on top of <code>http</code>/<code>https</code> module. Its README says:</p>\n<blockquote>\n<p><code>timeout</code> - Integer containing the number of milliseconds to wait for a server to send response headers (and start the response body) before aborting the request.</p>\n</blockquote>\n<p>However, as far as I checked the implementation, <code>timeout</code> is not applied to the timing of response headers as of v2.81.1.</p>\n<p>Currently this module emits the two types of timeout errors:</p>\n<ul>\n<li><code>ESOCKETTIMEDOUT</code>: Emitted from <code>http.ClientRequest.setTimeout()</code> described above, which uses <code>socket.setTimeout()</code>.</li>\n<li><code>ETIMEDOUT</code>: Emitted when a connection is not established in the given timeout. It was applied to the timing of response headers before v2.76.0.</li>\n</ul>\n<p>There is <a href=\"https://github.com/request/request/issues/2535\">a GitHub issue</a> for it, but I&#39;m not sure if it&#39;s intended and the README is outdated, or it&#39;s a bug.</p>\n<p>By the way, <code>request</code> provides a useful timing measurement feature that you can enable with <code>time</code> option. It will help you to define a proper timeout value.</p>\n<h3 id=\"-axios-module\">&quot;axios&quot; module</h3>\n<p><a href=\"https://github.com/mzabriskie/axios\"><code>axios</code></a> is another popular library that uses <code>Promise</code>. Like <code>request</code> module&#39;s README, its <code>timeout</code> option timeouts if the response status code and headers don&#39;t arrive in the given timeout.</p>\n<h2 id=\"browser-apis\">Browser APIs</h2>\n<p>While my initial interest was server-side HTTP requests, I become curious about browser APIs as I was investigating Node.js options.</p>\n<h3 id=\"xmlhttprequest\">XMLHttpRequest</h3>\n<p><a href=\"http://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/timeout\"><code>XMLHttpRequest.timeout</code></a> aborts a request after the given timeout and calls <code>ontimeout</code> event listeners. The documentation does not explain the exact timing, but I guess that it is until <code>readyState === 4</code>, which means that the entire response body has arrived.</p>\n<h3 id=\"fetch-\">fetch()</h3>\n<p>As far as I read <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch\"><code>fetch()</code>&#39;s documentation on MDN</a>, it does not have any way to specify a timeout. So we need to handle by ourselves. We can do that easily using <a href=\"http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\"><code>Promise.race()</code></a>.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">withTimeout</span>(<span class=\"hljs-params\">msecs, promise</span>) </span>{\n  <span class=\"hljs-keyword\">const</span> timeout = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> {\n    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> {\n      reject(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">'timeout'</span>));\n    }, msecs);\n  });\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Promise</span>.race([timeout, promise]);\n}\n\nwithTimeout(<span class=\"hljs-number\">1000</span>, fetch(<span class=\"hljs-string\">'https://foo.com/bar/'</span>))\n  .then(doSomething)\n  .catch(handleError);</code></pre><p>This kind of external approach works with any HTTP client and timeouts for the overall request and response. However, it does not abort the underlying HTTP request while preceding timeouts actually abort HTTP requests and save some resources.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Most of the HTTP request APIs in JavaScript doesn&#39;t offer timeout mechanism for the overall request and response. If you want to limit the maximum processing time for your piece of code, you have to prepare your own timeout solution. However, if your solution relies on a high-level abstraction like <code>Promise</code> and cannot abort underlying TCP socket and HTTP request when timeout, it is nice to use an existing low-level timeout mechanisms like <code>socket.setTimeout()</code> together to save some resources.</p>\n"},{"layout":"post","title":"How to export CommonJS and ES Module","date":"2017-01-05 22:11","comments":true,"categories":["JavaScript"],"url":"/blog/2017/01/05/how-to-export-commonjs-and-es-module/","content":"<p>After <a href=\"/blog/2017/01/05/main-jsnext-main-and-module/\">my previous post about jsnext:main and module</a>, there came another issue.</p>\n<ul>\n<li><a href=\"https://github.com/shuhei/material-colors/issues/16\">colors.es2015.js and colors.js have different APIs · Issue #16 · shuhei/material-colors</a>.</li>\n</ul>\n<p>Here is the twists and turns that I wandered to solve the problem.</p>\n<h2 id=\"exports\">Exports</h2>\n<p>The code of <code>material-colors</code> looked like the following.</p>\n<p><code>colors.js</code> specified in <code>main</code> (CommonJS version)</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-built_in\">module</span>.exports = {\n  <span class=\"hljs-attr\">red</span>: { <span class=\"hljs-comment\">/* ... */</span> },\n  <span class=\"hljs-attr\">blue</span>: { <span class=\"hljs-comment\">/* ... */</span> }\n};</code></pre><p><code>colors.es2015.js</code> specified in <code>jsnext:main/module</code> (ES Module version)</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> red = { <span class=\"hljs-comment\">/* ... */</span> };\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> blue = { <span class=\"hljs-comment\">/* ... */</span> };</code></pre><p>Then the ES Module file can get benefit of tree shaking if it&#39;s imported by named imports.</p>\n<h2 id=\"problem-of-having-only-named-exports\">Problem of having only named exports</h2>\n<p>The <code>colors.es2015.js</code> broke <code>react-color</code> when built with Webpack 2 because it was doing default import but <code>colors.es2015.js</code> didn&#39;t have default export.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> material <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'material-colors'</span>;\n<span class=\"hljs-built_in\">console</span>.log(material.red);</code></pre><p>So <a href=\"https://github.com/echenley\">@echenley</a> suggested to change it to a wildcard import.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> material <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'material-colors'</span>;\n<span class=\"hljs-built_in\">console</span>.log(material.red);</code></pre><p>It worked well, but I removed <code>jsnext:main</code> and <code>module</code> because other libraries with default import may break on Webpack 2 and <code>material-colors</code> is already tiny without tree shaking anyway.</p>\n<h2 id=\"have-a-default-export\">Have a default export</h2>\n<p>After a while, I came up with a better solution to have a default export in addition to named exports. Then it will work well with tree shaking and won&#39;t break default import. Pretty obvious after coming up.</p>\n<pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> red = { <span class=\"hljs-comment\">/* ... */</span> };\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> blue = { <span class=\"hljs-comment\">/* ... */</span> };\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n  <span class=\"hljs-attr\">red</span>: red,\n  <span class=\"hljs-attr\">blue</span>: blue\n};</code></pre><h2 id=\"so-\">So?</h2>\n<p>To keep maximum compatibility for CommonJS and ES Module:</p>\n<ul>\n<li>If your CommonJS module exports only one thing, like encouraged in the npm world, export it as a default export.</li>\n<li>If your CommonJS module exports multiple things, which essentially exports an object with them as properties, export named exports. In addition to it, it&#39;s safer to have a default export just in case for the problem described above.</li>\n</ul>\n"}],"title":"Shuhei Kagawa","nextPage":"/blog/pages/2/"}